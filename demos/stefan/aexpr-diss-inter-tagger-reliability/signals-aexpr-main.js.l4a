{"type":"Reference","version":"cacae10201c936d24265b88a809c54c8e334a853","content":"export default function({ types: t, template, traverse, }) {\n\n\n  /*MD ## Generic Signal Computation One Time per File MD*/\n  var setup = template(`\nvar aexprCallbacks = [],\n    signals = [],\n    solveSignals = false,\n    resolveSignals = function() {\n        if(!solveSignals) {\n            solveSignals = true;\n            signals.forEach(s => s());\n            solveSignals = false;\n            let nonSignalCB;\n            while(nonSignalCB = aexprCallbacks.pop()) {\n                nonSignalCB();\n            }\n}\n    },\n    newAExpr = function(axp) {\n        return {\n            onChange(cb) {\n                axp.onChange(val => {\n                    if(solveSignals) {\n                        aexprCallbacks.push(() => cb(axp.getCurrentValue()));\n                    } else {\n                        return cb(val);\n                    }\n                });\n            }\n        }\n    }\n`);\n\n  /*MD ## Replace assignemnt with Signal MD*/\n  var signal = template(`(aexpr(() => init).onChange(resolveSignals), signals.push(() => name = init), init)`);\n\n\n  /*MD ## Find Assginemnts and Instrument Assigments MD*/\n  return {\n    visitor: {\n      Program(program) {\n        let aexprs = new Set();\n        program.traverse({\n          CallExpression(path) {\n            let callee = path.get(\"callee\");\n            if (callee.isIdentifier() && callee.node.name === 'aexpr')\n              aexprs.add(path);\n          }\n        });\n        aexprs.forEach(path => path.replaceWith(template(`newAExpr(expr)`)({ expr: path.node })));\n\n        program.traverse({\n          Identifier(path) {\n            if (!path.parentPath.isVariableDeclarator()) { return; }\n\n            // const as substitute for 'signal' for now #TODO\n            var declaration = path.parentPath.parentPath.node;\n            if (declaration.kind !== 'const') { return; }\n            declaration.kind = 'let';\n\n            var init = path.parentPath.get('init');\n            init.replaceWith(signal({\n              init: init,\n              name: path.node\n            }).expression);\n          }\n        });\n\n        program.unshiftContainer(\"body\", setup());\n      }\n    }\n  };\n}\n"}
{"from":180,"to":516,"name":"color","color":"yellow"}
{"from":539,"to":547,"name":"color","color":"red"}
{"from":948,"to":952,"name":"color","color":"yellow"}
{"from":952,"to":958,"name":"color","color":"yellow"}
{"from":1016,"to":1023,"name":"color","color":"blue"}
{"from":1671,"to":1745,"name":"color","color":"blue"}
{"from":1815,"to":1879,"name":"color","color":"blue"}
{"from":1150,"to":1157,"name":"color","color":"red"}
{"from":1217,"to":1225,"name":"color","color":"yellow"}