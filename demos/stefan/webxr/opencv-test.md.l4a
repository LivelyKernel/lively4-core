{"type":"Reference","version":"16003d57580a367992021ba3a58b9221ba514cce","content":"# OpenCV.js Test\n\n<script>\nimport cv from 'https://lively-kernel.org/lively4/aexpr/src/external/opencv/opencv-4.5.0.js'\nimport {run} from './opencv-test.js';\n</script>\n\n<video id='videoInput' width='320' height='240' autoplay style='position: relative; display: inline-block;'></video>\n\n<div id='log'>starting</div>;\n\n<canvas id='canvasInput' width='320' height='240'></canvas>\n<canvas id=\"outputCanvas\" width='320' height='240' style='border: red 1px solid;'></canvas>\n<canvas id=\"outputRect\" width='320' height='240' style='border: red 1px solid;'></canvas>\n\n<canvas id=\"output\" width='320' height='240' style='border: red 1px solid;'></canvas>\n\n![hello](https://lively-kernel.org/lively4/aexpr/demos/stefan/webxr/schierke.png){id=turtok}\n<canvas id=\"turtokOut\" width='320' height='240' style='border: red 1px solid;'></canvas>\n\n<script>\nasync function run() {\n  const get = id => lively.query(this, '#' + id)\n\n  let video = get(\"videoInput\"); // video is the id of video tag\n  let canvasInput = get(\"canvasInput\"); // canvasInput is the id of <canvas>\n  let outputCanvas = get('outputCanvas')\n  let matchesDebugRenderingOutputCanvas = get('output')\n\n  let videoAccess;\n  videoAccess = navigator.mediaDevices.getUserMedia({ video: true, audio: false })\n    .then(function(stream) {\n    video.srcObject = stream;\n    video.play();\n  })\n    .catch(function(err) {\n    console.log(\"An error occurred! \" + err);\n  });\n\n  const turtok = get('turtok');\n  const turtokOut = get('turtokOut');\n\n  await cv['onRuntimeInitialized'];\n  await videoAccess.then(() => lively.sleep(1000))\n\n  const log = get('log')\n\n  {\n    // prep dataset\n    let referenceImage = cv.imread(turtok);\n    let refAnno = new cv.Mat();\n    cv.cvtColor(referenceImage, refAnno, cv.COLOR_RGBA2GRAY, 0);\n\n    let referenceKeypoints;\n    let referenceDescriptors;\n    let requestId;\n\n    const orb = new cv.ORB();\n    referenceKeypoints = new cv.KeyPointVector();\n    referenceDescriptors = new cv.Mat();\n    orb.detect(refAnno, referenceKeypoints);\n    orb.compute(refAnno, referenceKeypoints, referenceDescriptors);\n    // log.innerText = referenceKeypoints.size()\n\n    // refAnno\n    const color = new cv.Scalar(255, 255, 0, 255);\n    cv.drawKeypoints(refAnno, referenceKeypoints, refAnno, color);\n    for (let i = 0; i < referenceKeypoints.size(); ++i) {\n      const kp = referenceKeypoints.get(i);\n      const center = new cv.Point(kp.pt.x, kp.pt.y);\n      cv.circle(refAnno, center, 5, new cv.Scalar(0, 255, 0, 255), 1, cv.LINE_AA);\n    }\n    cv.imshow(turtokOut, refAnno);\n\n    // loop the vid capture\n    const cap = new cv.VideoCapture(video);\n    const processVideo = () => {\n      const newOrb = orb.clone()\n\n      const src = new cv.Mat(video.height, video.width, cv.CV_8UC4);\n      const gray = new cv.Mat();\n      const matcher = new cv.BFMatcher(cv.NORM_HAMMING, true);\n\n      cap.read(src);\n      cv.imshow(canvasInput, src);\n\n      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);\n\n      // Detect ORB features\n      const keypoints = new cv.KeyPointVector();\n      const descriptors = new cv.Mat();\n      newOrb.detect(gray, keypoints);\n      newOrb.compute(gray, keypoints, descriptors);\n\n      log.innerText = `frame start`\n      \n      const matches = new cv.DMatchVector();\n      matcher.match(referenceDescriptors, descriptors, matches);\n      \n      // Draw matches\n      const output = src.clone();\n      cv.drawMatches(referenceImage, referenceKeypoints, gray, keypoints, matches, output, new cv.Scalar(0, 255, 0, 255), new cv.Scalar(255, 0, 0, 255));\n\n    // Filter matches\n    let goodMatches = [];\n    for (let i = 0; i < matches.size(); i++) {\n      if (matches.get(i).distance < 50) { // You can adjust the threshold\n        goodMatches.push(matches.get(i));\n      }\n    }\n\n      log.innerText += `, ${goodMatches.length} good`\n\n      // Draw keypoints\n      const color = new cv.Scalar(0, 255, 0, 255);\n      cv.drawKeypoints(src, keypoints, src, color);\n      for (let i = 0; i < keypoints.size(); ++i) {\n        const kp = keypoints.get(i);\n        const center = new cv.Point(kp.pt.x, kp.pt.y);\n        cv.circle(gray, center, 5, new cv.Scalar(0, 255, 0, 255), 1, cv.LINE_AA);\n      }\n\n      // Draw matches\n      const output2 = src.clone();\n      if (goodMatches.length > 10) { // Minimum number of good matches to consider the reference image found\n        // Extract location of good matches\n        const srcPoints = [];\n        const dstPoints = [];\n        for (let i = 0; i < goodMatches.length; i++) {\n          srcPoints.push(referenceKeypoints.get(goodMatches[i].queryIdx).pt);\n          dstPoints.push(keypoints.get(goodMatches[i].trainIdx).pt);\n        }\n\n        // Convert points to Mat\n        const srcMat = cv.matFromArray(srcPoints.length, 1, cv.CV_32FC2, srcPoints);\n        const dstMat = cv.matFromArray(dstPoints.length, 1, cv.CV_32FC2, dstPoints);\n\n        // Find homography\n        const mask = new cv.Mat();\n        const H = cv.findHomography(srcMat, dstMat, cv.RANSAC, 5, mask);\n\n        // Use homography to check for object presence\n        log.innerText += `, homography ${H.empty ? 'empty' : 'yeah!'}`\n        if (!H.empty()) {\n          const hMask = new cv.Mat();\n          cv.findHomography(srcMat, dstMat, cv.RANSAC, 5, hMask);\n\n          // Count inliers\n          let inliers = 0;\n          for (let i = 0; i < hMask.rows; i++) {\n            if (hMask.data[i] === 1) {\n              inliers++;\n            }\n          }\n\n          // If enough inliers, consider the object found\n          log.innerText += `, ${inliers} good`\n          if (inliers > 10) {\n\n        const rectColor = new cv.Scalar(0, 255, 0, 255); // Green rectangle\n        const rectPoints = cv.matFromArray(4, 1, cv.CV_32FC2, [\n          0, 0,\n          referenceImage.cols, 0,\n          referenceImage.cols, referenceImage.rows,\n          0, referenceImage.rows\n        ]);\n            \n            const perspectivePoints = new cv.Mat();\n        cv.perspectiveTransform(rectPoints, perspectivePoints, H);\n\n        // Draw rectangle around the detected object\n        const pointsData = perspectivePoints.data32F;\n        cv.line(output, new cv.Point(pointsData[0], pointsData[1]), new cv.Point(pointsData[2], pointsData[3]), rectColor, 2);\n        cv.line(output, new cv.Point(pointsData[2], pointsData[3]), new cv.Point(pointsData[4], pointsData[5]), rectColor, 2);\n        cv.line(output, new cv.Point(pointsData[4], pointsData[5]), new cv.Point(pointsData[6], pointsData[7]), rectColor, 2);\n        cv.line(output, new cv.Point(pointsData[6], pointsData[7]), new cv.Point(pointsData[0], pointsData[1]), rectColor, 2);\n\n        rectPoints.delete();\n        perspectivePoints.delete();\n          }\n\n          hMask.delete();\n        }\n\n        srcMat.delete();\n        dstMat.delete();\n        H.delete();\n        mask.delete();\n      }\n\n      const outputRect = get('outputRect');\n      cv.imshow(outputRect, output2);\n      \n      cv.imshow(outputCanvas, gray);\n      cv.imshow(matchesDebugRenderingOutputCanvas, output);\n\n      src.delete()\n      gray.delete()\n      matches.delete();\n      output.delete();\n      keypoints.delete()\n      descriptors.delete()\n      newOrb.delete()\n\n      if(!lively.allParents(lively.query(this, '*'), [], true).includes(document.body)) {\n        lively.warn('BREAK')\n        referenceImage.delete();\n        referenceKeypoints.delete();\n        referenceDescriptors.delete();\n        matcher.delete()\n        orb.delete()\n        cap.delete()\n      } else {\n        requestAnimationFrame(processVideo);\n      }\n    }\n\n    processVideo();\n  }\n}\n\nrun.call(this)\n</script>\n\n"}
{"from":549,"to":549,"name":"color","color":"#9ecae1"}
{"from":-1292,"to":-1292,"name":"color","color":"#9ecae1"}
{"from":-2086,"to":-2086,"name":"color","color":"#9ecae1"}
{"from":3264,"to":3264,"name":"color","color":"#9ecae1"}
{"from":3265,"to":3265,"name":"color","color":"#9ecae1"}