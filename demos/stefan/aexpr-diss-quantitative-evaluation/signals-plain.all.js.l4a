{"type":"Reference","version":"75f9db67d6101e0a73349586a1f2773cd9b5db93","content":"const IS_EXPLICIT_SCOPE_OBJECT = Symbol('FLAG: generated scope object');\n\nexport default function({ types: t, template, traverse, }) {\n    var setup = template(`\nconst signals = [],\n    adjustedDependencies = [],\n    defineSignal = function(scope, name, init, solve) {\n      let signal = new Signal(scope, name, init, solve);\n      signals.push(signal);\n      return signal.initialize();\n    },\n    resolveSignals = function(starting) {\n      let startingIndex = signals.indexOf(starting);\n      signals\n        .filter((s, i) => i >= startingIndex)\n        .forEach(s => {\n          if(adjustedDependencies.some((dep) => {\n              let scope = dep[0],\n                  name = dep[1];\n              return s.hasDependency(scope, name);\n            })) {\n            s.resolve();\n            adjustedDependencies.push([s.scope, s.name]);\n            s.initialize();\n          }\n        });\n    },\n    getLocal = function(scope, name) {\n      if(Signal.determineDepencencies) {\n        Signal.currentSignal.addDependency(scope, name);\n      }\n    },\n    setLocal = function(scope, name) {\n      if(Signal.solving) { return; }\n      let triggeredSignal = signals.find(s => s.hasDependency(scope, name));\n      if(triggeredSignal) {\n        Signal.solving = true;\n        adjustedDependencies.length = 0;\n        adjustedDependencies.push([scope, name]);\n        resolveSignals(triggeredSignal);\n        Signal.solving = false;\n      }\n    };\n\nconst compositeKeyStore = new Map();\n\nclass Signal {\n  constructor(scope, name, init, solve) {\n    this.scope = scope,\n    this.name = name,\n    this.init = init,\n    this.solve = solve;\n    this.dependencies = new Set();\n  }\n  initialize() {\n    this.dependencies.clear();\n    Signal.determineDepencencies = true;\n    Signal.currentSignal = this;\n    let result = this.init();\n    Signal.determineDepencencies = false;\n    Signal.currentSignal = undefined;\n    return result;\n  }\n  addDependency(scope, name) {\n    this.dependencies.add(CompositeKey.get(scope, name));\n  }\n  hasDependency(scope, name) {\n    return this.dependencies.has(CompositeKey.get(scope, name));\n  }\n  resolve() {\n    this.solve();\n  }\n}\nSignal.currentSignal = undefined;\nSignal.determineDepencencies = false;\nSignal.solving = false;\n\nclass CompositeKey {\n    static get(obj1, obj2) {\n        if(!compositeKeyStore.has(obj1)) {\n            compositeKeyStore.set(obj1, new Map());\n        }\n        let secondKeyMap = compositeKeyStore.get(obj1);\n        if(!secondKeyMap.has(obj2)) {\n            secondKeyMap.set(obj2, {});\n        }\n        return secondKeyMap.get(obj2);\n    }\n    static clear() {\n        compositeKeyStore.clear();\n    }\n}`);\n    \n    return {\n        visitor: {\n            Program(program, state) {\n                function isVariable(path) {\n                  // - filter out with negative conditions\n                  if(t.isLabeledStatement(path.parent) && path.parentKey === 'label') return false;\n                  if(t.isBreakStatement(path.parent) && path.parentKey === 'label') return false;\n                  if(t.isForInStatement(path.parent) && path.parentKey === 'left') return false;\n                  if(t.isFunctionExpression(path.parent) && path.parentKey === 'id') return false;\n                  if(t.isImportDefaultSpecifier(path.parent) && path.parentKey === 'local') return false;\n                  if(t.isCatchClause(path.parent) && path.parentKey === 'param') return false;\n                  if(t.isObjectProperty(path.parent) && path.parentKey === 'key') return false;\n                  if(t.isClassDeclaration(path.parent)) return false;\n                  if(t.isClassMethod(path.parent)) return false;\n                  if(t.isImportSpecifier(path.parent)) return false; // correct?\n                  if(t.isMemberExpression(path.parent) && path.parentKey === 'property' && !path.parent.computed) return false;\n                  if(t.isObjectMethod(path.parent)) return false;\n                  if(t.isFunctionDeclaration(path.parent)) return false;\n                  if((t.isArrowFunctionExpression(path.parent) && path.parentKey === 'params')) return false;\n                  if((t.isFunctionExpression(path.parent) && path.parentKey === 'params')) return false;\n                  if(t.isRestElement(path.parent)) return false;\n              \n                  return true;\n                }\n\n                function getIdentifierForExplicitScopeObject(parentWithScope) {\n                    let bindings = parentWithScope.scope.bindings;\n                    let scopeName = Object.keys(bindings).find(key => {\n                        return bindings[key].path &&\n                            bindings[key].path.node &&\n                            bindings[key].path.node.id &&\n                            bindings[key].path.node.id[IS_EXPLICIT_SCOPE_OBJECT]\n                    });\n\n                    if(scopeName) {\n                        return t.identifier(scopeName);\n                    } else {\n                        let uniqueIdentifier = parentWithScope.scope.generateUidIdentifier('scope');\n                        uniqueIdentifier[IS_EXPLICIT_SCOPE_OBJECT] = true;\n\n                        parentWithScope.scope.push({\n                            kind: 'let',\n                            id: uniqueIdentifier,\n                            init: t.objectExpression([\n                              t.objectProperty(t.identifier('name'), t.stringLiteral(uniqueIdentifier.name))\n                            ])\n                        });\n                        return uniqueIdentifier;\n                    }\n                }\n\n                function getScopeIdentifierForVariable(path) {\n                    if(path.scope.hasBinding(path.node.name)) {\n                        let parentWithScope = path.findParent(par =>\n                            par.scope.hasOwnBinding(path.node.name)\n                        );\n                        if(parentWithScope) {\n                            return getIdentifierForExplicitScopeObject(parentWithScope);\n                        }\n                    } else {\n                        return t.identifier('window');\n                    }\n                }\n                \n                function bubbleThroughPattern(path) {\n                  if(path.parentPath.isArrayPattern() && path.parentKey === 'elements') return bubbleThroughPattern(path.parentPath);\n                  if(path.parentPath.isRestElement() && path.parentKey === 'argument') return bubbleThroughPattern(path.parentPath);\n                  if(path.parentPath.isObjectPattern() && path.parentKey === 'properties') return bubbleThroughPattern(path.parentPath);\n                  if(path.parentPath.isObjectProperty() && path.parentKey === 'value') return bubbleThroughPattern(path.parentPath);\n                  if(path.parentPath.isRestProperty() && path.parentKey === 'argument') return bubbleThroughPattern(path.parentPath);\n                  return path;\n                }\n                \n                function isLocallyDefined(path) {\n                  return path.scope.hasBinding(path.node.name) && path.findParent(par =>\n                    par.scope.hasOwnBinding(path.node.name)\n                  );\n                }\n                \n                function identifierInDeclaration(identifierPath) {\n                  if(!identifierPath.findParent(p=>p.isDeclaration())) { return false; }\n                  let pattern = bubbleThroughPattern(identifierPath);\n                  return pattern.parentPath.isVariableDeclarator() && pattern.parentKey === 'id';\n                }\n                \n                program.traverse({\n                  UpdateExpression(path) {\n                    path.replaceWith(t.binaryExpression(\n                      path.node.operator === '++' ? '-' : '+',\n                      t.assignmentExpression(\n                        path.node.operator === '++' ? '+=' : '-=',\n                        path.get('argument').node,\n                        t.numberLiteral(1)\n                      ),\n                      t.numberLiteral(1)\n                    ));\n                  }\n                });\n\n                let localReads = new Set();\n                let globalReads = new Set();\n                let localWrites = new Set();\n                let signalDeclarators = new Set();\n                let objPropReads = new Set();\n                let objPropWrites = new Set();\n                let objPropCalls = new Set();\n                \n                program.traverse({\n                  MemberExpression(path) {\n                    if(path.parentPath.isAssignmentExpression() && path.parentKey === 'left') {\n                      objPropWrites.add(path);\n                    } else if(path.parentPath.isCallExpression() && path.parentKey === 'callee') {\n                      objPropCalls.add(path);\n                    } else {\n                      objPropReads.add(path);\n                    }\n                  }\n                });\n                \n                program.traverse({\n                  Identifier(path) {\n                    if(path.parentPath.isAssignmentExpression() && path.parentKey === 'left') {\n                      localWrites.add(path);\n                    } else if (isVariable(path) && isLocallyDefined(path) && !identifierInDeclaration(path)){\n                      localReads.add(path);\n                    } else if (isVariable(path) && isLocallyDefined(path)) {\n                      let pattern = bubbleThroughPattern(path);\n                      // const as substitute for 'signal' for now #TODO\n                      if(pattern.parentPath.parentPath.node.kind === 'const') {\n                        signalDeclarators.add(pattern.parentPath);\n                      }\n                    } else if(isVariable(path) && !isLocallyDefined(path)) {\n                      globalReads.add(path);\n                    }\n                  }\n                });\n                \n                let rewriteGetter = path => {\n                  path.replaceWith(template(`((result, scope, name) => {\n                      getLocal(scope, name);\n                      return result;\n                    })(IDENTIFIER, SCOPE, NAME)`)({\n                      IDENTIFIER: path.node,\n                      SCOPE: getScopeIdentifierForVariable(path),\n                      NAME: t.stringLiteral(path.node.name)\n                    }));\n                };\n                globalReads.forEach(rewriteGetter);\n                localReads.forEach(rewriteGetter);\n                \n                signalDeclarators.forEach(decl => {\n                  decl.parentPath.node.kind = 'let';\n                  let init = decl.get('init'),\n                      id = decl.get('id');\n                  init.replaceWith(template(`defineSignal(SCOPE, NAME, () => INIT, () => VAR = INIT)`)({\n                    SCOPE: getScopeIdentifierForVariable(id),\n                    NAME: t.stringLiteral(id.node.name),\n                    VAR: t.identifier(id.node.name),\n                    INIT: init\n                  }));\n                })\n\n                localWrites.forEach(path => {\n                  let assignment = path.parentPath;\n                  assignment.replaceWith(\n                    template(`((result, scope, name) => {\n                      setLocal(scope, name);\n                      return result;\n                    })(ASSIGNMENT, SCOPE, NAME)`)({\n                      ASSIGNMENT: assignment.node,\n                      SCOPE: getScopeIdentifierForVariable(path),\n                      NAME: t.stringLiteral(path.node.name)\n                    })\n                  );\n                });\n                \n                objPropReads.forEach(p => {\n                  program.unshiftContainer('body', t.expressionStatement(t.stringLiteral(p.node.property.name)));\n                })\n                objPropReads.forEach(path => {\n                  let obj = path.get('object'),\n                      prop = path.get('property'),\n                      computed = path.node.computed;\n                  path.replaceWith(template(`((obj, prop) => {\n                      getLocal(obj, prop);\n                      return obj[prop];\n                    })(OBJECT, PROP_NAME)`)({\n                      OBJECT: obj.node,\n                      PROP_NAME: computed ? prop.node : t.stringLiteral(prop.node.name)\n                    }));\n                });\n                objPropWrites.forEach(path => {\n                  let assignment = path.parentPath;\n                  let operator = assignment.node.operator;\n                  let obj = path.get('object'),\n                      prop = path.get('property'),\n                      computed = path.node.computed;\n                  assignment.replaceWith(\n                    template(`((obj, prop, value) => {\n                      let result = obj[prop] ${operator} value;\n                      setLocal(obj, prop);\n                      return result;\n                    })(OBJECT, PROP_NAME, VALUE)`)({\n                      OBJECT: obj.node,\n                      PROP_NAME: computed ? prop.node : t.stringLiteral(prop.node.name),\n                      VALUE: assignment.node.right\n                    })\n                  );\n                });\n                objPropCalls.forEach(path => {\n                  let obj = path.get('object'),\n                      prop = path.get('property'),\n                      computed = path.node.computed;\n                  path.replaceWith(template(`((obj, prop, ) => {\n                      getLocal(obj, prop);\n                      return obj[prop].bind(obj);\n                    })(OBJECT, PROP_NAME)`)({\n                      OBJECT: obj.node,\n                      PROP_NAME: computed ? prop.node : t.stringLiteral(prop.node.name)\n                    }));\n                });\n\n                program.unshiftContainer(\"body\", setup());\n            }\n        }\n    };\n}"}
{"from":0,"to":186,"name":"color","color":"#fdd49e"}
{"from":186,"to":211,"name":"color","color":"#a1d99b"}
{"from":217,"to":258,"name":"color","color":"#fdd49e"}
{"from":260,"to":265,"name":"color","color":"#a1d99b"}
{"from":265,"to":316,"name":"color","color":"#fdd49e"}
{"from":318,"to":323,"name":"color","color":"#a1d99b"}
{"from":323,"to":425,"name":"color","color":"#fdd49e"}
{"from":425,"to":433,"name":"color","color":"#a1d99b"}
{"from":433,"to":443,"name":"color","color":"#fdd49e"}
{"from":443,"to":463,"name":"color","color":"#a1d99b"}
{"from":463,"to":471,"name":"color","color":"#fdd49e"}
{"from":471,"to":559,"name":"color","color":"#a1d99b"}
{"from":559,"to":572,"name":"color","color":"#fdd49e"}
{"from":572,"to":855,"name":"color","color":"#a1d99b"}
{"from":855,"to":869,"name":"color","color":"#fdd49e"}
{"from":869,"to":892,"name":"color","color":"#a1d99b"}
{"from":892,"to":1243,"name":"color","color":"#fdd49e"}
{"from":1243,"to":1365,"name":"color","color":"#a1d99b"}
{"from":1365,"to":1380,"name":"color","color":"#fdd49e"}
{"from":1380,"to":1395,"name":"color","color":"#a1d99b"}
{"from":1395,"to":1396,"name":"color","color":"#fdd49e"}
{"from":1396,"to":1428,"name":"color","color":"#a1d99b"}
{"from":1428,"to":1530,"name":"color","color":"#fdd49e"}
{"from":1532,"to":1537,"name":"color","color":"#a1d99b"}
{"from":1537,"to":1607,"name":"color","color":"#fdd49e"}
{"from":1613,"to":1631,"name":"color","color":"#a1d99b"}
{"from":1631,"to":2113,"name":"color","color":"#fdd49e"}
{"from":2115,"to":2116,"name":"color","color":"#a1d99b"}
{"from":2155,"to":10820,"name":"color","color":"#fdd49e"}
{"from":10822,"to":10838,"name":"color","color":"#a1d99b"}
{"from":10838,"to":10947,"name":"color","color":"#fdd49e"}
{"from":11015,"to":13938,"name":"color","color":"#fdd49e"}
{"from":211,"to":217,"name":"color","color":"#fdd49e"}
{"from":258,"to":260,"name":"color","color":"#fdd49e"}
{"from":316,"to":318,"name":"color","color":"#fdd49e"}
{"from":1530,"to":1532,"name":"color","color":"#fdd49e"}
{"from":1607,"to":1613,"name":"color","color":"#fdd49e"}
{"from":2149,"to":2155,"name":"color","color":"#a1d99b"}
{"from":2122,"to":2149,"name":"color","color":"#a1d99b"}
{"from":2116,"to":2122,"name":"color","color":"#fdd49e"}
{"from":2113,"to":2115,"name":"color","color":"#fdd49e"}
{"from":10983,"to":11015,"name":"color","color":"#a1d99b"}
{"from":10947,"to":10983,"name":"color","color":"#fdd49e"}
{"from":10820,"to":10822,"name":"color","color":"#fdd49e"}