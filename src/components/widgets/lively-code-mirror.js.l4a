{"type":"Reference","version":"1008817461e2515553a1e089ee036f0081461554","content":"/*MD \n# CodeMirror\n\nWorkspace / main source code editing component. \n\n![](lively-code-mirror.png){height=200}\n\nMD*/\n\nimport { promisedEvent, through, uuid as generateUUID } from 'utils';\nimport boundEval from 'src/client/bound-eval.js';\nimport Morph from \"src/components/widgets/lively-morph.js\"\nimport diff from 'src/external/diff-match-patch.js';\nimport SyntaxChecker from 'src/client/syntax.js';\nimport { debounce } from \"utils\";\nimport Preferences from 'src/client/preferences.js';\nimport {pt} from 'src/client/graphics.js';\nimport 'src/client/stablefocus.js';\nimport Strings from 'src/client/strings.js';\nimport { letsScript } from 'src/client/vivide/vivide.js';\nimport LivelyCodeMirrorWidgetImport from 'src/components/widgets/lively-code-mirror-widget-import.js';\nimport LivelyCodeMirrorCodeProvider from 'src/components/widgets/lively-code-mirror-code-provider.js';\nimport openMenu from 'src/components/widgets/lively-code-mirror-context-menu.js';\nimport * as spellCheck from \"src/external/codemirror-spellcheck.js\"\nimport {isSet} from 'utils'\nimport fake from \"./lively-code-mirror-fake.js\"\nimport CodeMirror from \"src/external/code-mirror/lib/codemirror.js\"\nself.CodeMirror = CodeMirror // for modules\nlet loadPromise = undefined;\nimport { loc, range } from 'utils';\n\nimport _ from 'src/external/lodash/lodash.js'\n\n\nexport function stripErrorString(s) {\n  return s.toString()\n    .replace(/Error: workspace(js)?:[^:]*:/,\"Error:\")\n    .replace(/\\n {2}Evaluating workspace(js)?:.*/,\"\")\n    .replace(/\\n {2}Loading workspace(js)?:.*/,\"\")\n    .replace(/\\n {2}Instantiating workspace(js)?:.*/,\"\")\n}\n\nfunction posEq(a, b) {return a.line == b.line && a.ch == b.ch;}\n\n\nexport default class LivelyCodeMirror extends HTMLElement {\n\n  fake(...args) {\n    fake(this.editor, ...args)\n  }\n  \n  get mode() {\n    return this.getAttribute('mode');\n  }\n  set mode(val) {\n    return this.setAttribute('mode', val);\n  }\n\n  static get codeMirrorPath() {\n     return  lively4url + \"/src/external/code-mirror/\"\n  }\n\n  static async loadModule(path, force) {\n    if (!self.CodeMirror) {\n      console.warn(\"CodeMirror is missing, could not initialize \" + path )\n      return \n    }\n    var code = await fetch(this.codeMirrorPath + path).then(r => r.text())\n    try {\n      eval(code)\n    } catch(e) {\n      console.error(\"Could not load CodeMirror module \" + path, e)\n    }\n    // return lively.loadJavaScriptThroughDOM(\"codemirror_\"+path.replace(/[^A-Za-z]/g,\"\"),\n    //   this.codeMirrorPath + path, force)\n  }\n\n  static async loadCSS(path) {\n    return lively.loadCSSThroughDOM(\"codemirror_\" + path.replace(/[^A-Za-z]/g,\"\"),\n       this.codeMirrorPath + path)\n  }\n\n  static async loadModules(force) {\n    // console.log(\"loadModules\", loadPromise);\n    if (loadPromise && !force) return loadPromise\n    loadPromise = (async () => {\n\n\n      await this.loadModule(\"addon/fold/foldcode.js\")\n\n      await this.loadModule(\"mode/javascript/javascript.js\")\n      await this.loadModule(\"mode/xml/xml.js\")\n      await this.loadModule(\"mode/css/css.js\")\n      await this.loadModule(\"mode/diff/diff.js\")\n\n      await this.loadModule(\"mode/markdown/markdown.js\")\n      await this.loadModule(\"mode/htmlmixed/htmlmixed.js\")\n      await this.loadModule(\"addon/mode/overlay.js\")\n      await this.loadModule(\"mode/gfm/gfm.js\")\n      await this.loadModule(\"mode/stex/stex.js\")\n      await this.loadModule(\"mode/jsx/jsx.js\")\n      await this.loadModule(\"mode/python/python.js\")\n      await this.loadModule(\"mode/clike/clike.js\")\n      await this.loadModule(\"mode/shell/shell.js\")\n      \n      await this.loadModule(\"addon/edit/matchbrackets.js\")\n      await this.loadModule(\"addon/edit/closetag.js\")\n      await this.loadModule(\"addon/edit/closebrackets.js\")\n      await this.loadModule(\"addon/edit/continuelist.js\")\n      await this.loadModule(\"addon/edit/matchtags.js\")\n      await this.loadModule(\"addon/edit/trailingspace.js\")\n      await this.loadModule(\"addon/hint/show-hint.js\")\n      await this.loadModule(\"addon/hint/javascript-hint.js\")\n      await this.loadModule(\"addon/search/searchcursor.js\")\n      await this.loadModule(\"addon/search/search.js\")\n      await this.loadModule(\"addon/search/jump-to-line.js\")\n      await this.loadModule(\"addon/search/matchesonscrollbar.js\")\n      await this.loadModule(\"addon/search/match-highlighter.js\")\n      await this.loadModule(\"addon/scroll/annotatescrollbar.js\")\n      await this.loadModule(\"addon/comment/comment.js\")\n      await this.loadModule(\"addon/dialog/dialog.js\")\n      await this.loadModule(\"addon/scroll/simplescrollbars.js\")\n\n      //await System.import(\"https://raw.githubusercontent.com/jshint/jshint/master/dist/jshint.js\");\n      //await lively.loadJavaScriptThroughDOM(\"jshintAjax\", \"https://ajax.aspnetcdn.com/ajax/jshint/r07/jshint.js\");\n      //await lively.loadJavaScriptThroughDOM(\"eslint\", \"http://eslint.org/js/app/eslint.js\");\n      await this.loadModule(\"addon/lint/lint.js\");\n      await this.loadModule(\"addon/lint/javascript-lint.js\");\n      await this.loadModule(\"../eslint/eslint.js\");\n      // await this.loadModule(\"../eslint/eslint-lint.js\", force);\n      await System.import(lively4url + '/src/external/eslint/eslint-lint.js');\n      await this.loadModule(\"addon/merge/merge.js\")\n      await this.loadModule(\"addon/selection/mark-selection.js\")\n      await this.loadModule(\"keymap/sublime.js\")\n      await System.import(lively4url + '/src/components/widgets/lively-code-mirror-hint.js')\n\n      this.loadCSS(\"addon/hint/show-hint.css\")\n      this.loadCSS(\"addon/lint/lint.css\")\n      lively.loadCSSThroughDOM(\"CodeMirrorCSS\", lively4url + \"/src/components/widgets/lively-code-mirror.css\")\n    })()\n    return loadPromise\n  }\n\n  // #TODO #Refactor not needed anymore\n  static async loadTernModules() {\n    if (this.ternIsLoaded) return;\n\n    await this.loadModule(\"addon/tern/tern.js\")\n\n    var terndir = lively4url + '/src/external/tern/'\n    await lively.loadJavaScriptThroughDOM(\"tern_acorn\", terndir + 'acorn.js')\n    await lively.loadJavaScriptThroughDOM(\"tern_acorn_loose\", terndir + 'acorn_loose.js')\n    await lively.loadJavaScriptThroughDOM(\"tern_walk\", terndir + 'walk.js')\n    await lively.loadJavaScriptThroughDOM(\"tern_polyfill\", terndir + 'polyfill.js')\n    await lively.loadJavaScriptThroughDOM(\"tern_signal\", terndir + 'signal.js')\n    await lively.loadJavaScriptThroughDOM(\"tern_tern\", terndir + 'tern.js')\n    await lively.loadJavaScriptThroughDOM(\"tern_def\", terndir + 'def.js')\n    await lively.loadJavaScriptThroughDOM(\"tern_comment\", terndir + 'comment.js')\n    await lively.loadJavaScriptThroughDOM(\"tern_infer\", terndir + 'infer.js')\n    await lively.loadJavaScriptThroughDOM(\"tern_plugin_modules\", terndir + 'modules.js')\n    await lively.loadJavaScriptThroughDOM(\"tern_plugin_esmodules\", terndir + 'es_modules.js')\n    this.ternIsLoaded = true;\n  }\n  \n  astCapabilities(cm) {\n    if(!this.myASTCapabilities) {\n      this.myASTCapabilities = System.import('src/components/widgets/ast-capabilities.js')\n        .then(m => {\n          var codeProvider = new LivelyCodeMirrorCodeProvider(this, cm);\n          var capabilities = new m.default(codeProvider);\n          cm.on(\"change\", (() => {\n            capabilities.codeChanged();\n          }).debounce(200));\n          return capabilities;\n        });\n    }\n    \n    return this.myASTCapabilities;\n  }\n  \n  autoCompletion(cm) {\n    return System.import('src/components/widgets/auto-completion.js')\n      .then(m => new m.default(this, cm));\n  }\n  \n  get ternWrapper() {\n    return System.import('src/components/widgets/tern-wrapper.js')\n      .then(m => {\n        this.ternLoaded = true\n        return m.TernCodeMirrorWrapper\n      });\n  }\n\n  initialize() {\n    this._attrObserver = new MutationObserver(mutations => {\n      mutations.forEach(mutation => {\n        if(mutation.type == \"attributes\") {\n          // console.log(\"observation\", mutation.attributeName,mutation.target.getAttribute(mutation.attributeName));\n          this.attributeChangedCallback(\n            mutation.attributeName,\n            mutation.oldValue,\n            mutation.target.getAttribute(mutation.attributeName)\n          )\n        }\n      });\n    });\n    this._attrObserver.observe(this, { attributes: true });\n  }\n\n  applyAttribute(attr) {\n    var value = this.getAttribute(attr)\n    if (value !== undefined) {\n      this.setAttribute(attr, value)\n    }\n  }\n\n  async attachedCallback() {\n    if (this.isLoading || this.editor ) return;\n    this.isLoading = true\n    this.root = this.shadowRoot // used in code mirror to find current element\n    await LivelyCodeMirror.loadModules(); // lazy load modules...\n    \n    if (this.textContent) {\n      var value = this.decodeHTML(this.textContent);\n    } else {\n      value = this.value || \"\";\n    }\n    this.editView(value)\n    this.isLoading = false\n    // console.log(\"[editor] #dispatch editor-loaded\")\n    var event = new CustomEvent(\"editor-loaded\")\n    // event.stopPropagation();\n    this.dispatchEvent(event)\n    this[\"editor-loaded\"] = true // event can sometimes already be fired\n  }\n\n  async editorLoaded() {\n    if(!this[\"editor-loaded\"]) {\n      return promisedEvent(this, \"editor-loaded\");\n    }\n  }\n\n  editView(value) {\n    if (!value) value = this.value || \"\";\n    var container = this.shadowRoot.querySelector(\"#code-mirror-container\")\n    container.innerHTML = \"\"\n    this.setEditor(CodeMirror(container, {\n      value: value,\n      lineNumbers: true,\n      gutters: [\"leftgutter\", \"CodeMirror-linenumbers\", \"rightgutter\", \"CodeMirror-lint-markers\"],\n      lint: true\n    }));\n    \n    //load astCapabilities\n    this.astCapabilities(this.editor);\n  }\n\n  setEditor(editor) {\n    this.editor = editor\n\t\tthis.setupEditor()\n  }\n\n  setupEditor() {\n    var editor = this.editor;\n    if (this.mode) {\n      editor.setOption(\"mode\", this.mode);\n    }\n    this.setupEditorOptions(editor)\n    // edit addons\n    // editor.setOption(\"showTrailingSpace\", true)\n    // editor.setOption(\"matchTags\", true)\n\n    editor.on(\"change\", evt => this.dispatchEvent(new CustomEvent(\"change\", {detail: evt})));\n    editor.on(\"change\", (() => this.checkSyntax()).debounce(500));\n    \n    editor.on(\"cursorActivity\", (() => this.onCursorActivity()).debounce(500));\n    \n\t\t// apply attributes\n    _.map(this.attributes, ea => ea.name).forEach(ea => this.applyAttribute(ea));\n\n    // if(Preferences.get('UseTernInCodeMirror')) {\n    //   this.enableTern();\n    // }\n    editor.on(\"keydown\", (...args) => this.keyEvent(...args));\n  }\n  \n  keyEvent(cm, evt) {\n    \n    if (this.classList.contains('ast-mode') && !evt.repeat) {\n      function unifiedKeyDescription(e) {\n        const alt = e.altKey ? 'Alt-' : '';\n        const ctrl = e.ctrlKey ? 'Cctrl-' : '';\n        const shift = e.shiftKey ? 'Shift-' : '';\n        return ctrl + shift + alt + e.key;\n      }\n      const operations = {\n        Escape: () => {\n          this.classList.remove('ast-mode');\n        },\n        i: () => {\n          this.astCapabilities(cm).then(ac => ac.inlineLocalVariable());\n        },\n      };\n      \n      const operation = operations[unifiedKeyDescription(evt)];\n      if (operation) {\n        evt.preventDefault();\n        evt.codemirrorIgnore = true;\n\n        operation();\n      } else {\n        lively.notify(unifiedKeyDescription(evt), [this, cm, evt])\n      }\n    }\n  }\n  \n  clearHistory() {\n    var cm = this.editor;\n    cm.getDoc().clearHistory()\n  }\n  \n  addKeys(keymap) {\n    var keys = this.ensureExtraKeys()\n    this.extraKeys = Object.assign(keys, keymap)\n  }\n  \n  \n  ensureExtraKeys() {\n    if (!this.extraKeys) {\n      var editor = this.editor\n      this.extraKeys = {\n        \"Alt-1\": cm => this.astCapabilities(cm).then(ac => ac.alt1()),\n        \"Ctrl-Alt-1\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAlt1()),\n        \"Shift-Alt-1\": cm => this.astCapabilities(cm).then(ac => ac.shiftAlt1()),\n        \"Alt-2\": cm => this.astCapabilities(cm).then(ac => ac.alt2()),\n        \"Ctrl-Alt-2\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAlt2()),\n        \"Shift-Alt-2\": cm => this.astCapabilities(cm).then(ac => ac.shiftAlt2()),\n        \"Alt-3\": cm => this.astCapabilities(cm).then(ac => ac.alt3()),\n        \"Ctrl-Alt-3\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAlt3()),\n        \"Shift-Alt-3\": cm => this.astCapabilities(cm).then(ac => ac.shiftAlt3()),\n        \"Alt-4\": cm => this.astCapabilities(cm).then(ac => ac.alt4()),\n        \"Ctrl-Alt-4\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAlt4()),\n        \"Shift-Alt-4\": cm => this.astCapabilities(cm).then(ac => ac.shiftAlt4()),\n        \"Alt-5\": cm => this.astCapabilities(cm).then(ac => ac.alt5()),\n        \"Ctrl-Alt-5\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAlt5()),\n        \"Shift-Alt-5\": cm => this.astCapabilities(cm).then(ac => ac.shiftAlt5()),\n        \"Alt-6\": cm => this.astCapabilities(cm).then(ac => ac.alt6()),\n        \"Ctrl-Alt-6\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAlt6()),\n        \"Shift-Alt-6\": cm => this.astCapabilities(cm).then(ac => ac.shiftAlt6()),\n        \"Alt-7\": cm => this.astCapabilities(cm).then(ac => ac.alt7()),\n        \"Ctrl-Alt-7\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAlt7()),\n        \"Shift-Alt-7\": cm => this.astCapabilities(cm).then(ac => ac.shiftAlt7()),\n        \"Alt-8\": cm => this.astCapabilities(cm).then(ac => ac.alt8()),\n        \"Ctrl-Alt-8\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAlt8()),\n        \"Shift-Alt-8\": cm => this.astCapabilities(cm).then(ac => ac.shiftAlt8()),\n        \"Alt-9\": cm => this.astCapabilities(cm).then(ac => ac.alt9()),\n        \"Ctrl-Alt-9\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAlt9()),\n        \"Shift-Alt-9\": cm => this.astCapabilities(cm).then(ac => ac.shiftAlt9()),\n        \"Alt-0\": cm => this.astCapabilities(cm).then(ac => ac.alt0()),\n        \"Ctrl-Alt-0\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAlt0()),\n        \"Shift-Alt-0\": cm => this.astCapabilities(cm).then(ac => ac.shiftAlt0()),\n\n        \"Alt-Q\": cm => this.astCapabilities(cm).then(ac => ac.altQ()),\n        \"Ctrl-Alt-Q\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltQ()),\n        \"Shift-Alt-Q\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltQ()),\n        \"Alt-W\": cm => this.astCapabilities(cm).then(ac => ac.altW()),\n        \"Ctrl-Alt-W\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltW()),\n        \"Shift-Alt-W\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltW()),\n        \"Alt-E\": cm => this.astCapabilities(cm).then(ac => ac.altE()),\n        \"Ctrl-Alt-E\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltE()),\n        \"Shift-Alt-E\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltE()),\n        \"Alt-R\": cm => this.astCapabilities(cm).then(ac => ac.altR()),\n        \"Ctrl-Alt-R\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltR()),\n        \"Shift-Alt-R\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltR()),\n        \"Alt-T\": cm => this.astCapabilities(cm).then(ac => ac.altT()),\n        \"Ctrl-Alt-T\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltT()),\n        \"Shift-Alt-T\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltT()),\n        \"Alt-Y\": cm => this.astCapabilities(cm).then(ac => ac.altY()),\n        \"Ctrl-Alt-Y\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltY()),\n        \"Shift-Alt-Y\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltY()),\n        // #KeyboardShortcut Alt-U Replace parent node with selection\n        \"Alt-U\": cm => this.astCapabilities(cm).then(ac => ac.replaceParentWithSelection()),\n        \"Ctrl-Alt-U\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltU()),\n        \"Shift-Alt-U\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltU()),\n        \"Alt-I\": cm => this.astCapabilities(cm).then(ac => ac.altI()),\n        \"Ctrl-Alt-I\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltI()),\n        \"Shift-Alt-I\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltI()),\n        // #KeyboardShortcut Alt-O Insert new line below\n        \"Alt-O\": cm => this.astCapabilities(cm).then(ac => ac.newlineAndIndent(true)),\n        \"Ctrl-Alt-O\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltO()),\n        // #KeyboardShortcut Shift-Alt-O Insert new line above\n        \"Shift-Alt-O\": cm => this.astCapabilities(cm).then(ac => ac.newlineAndIndent(false)),\n        \"Alt-P\": cm => this.astCapabilities(cm).then(ac => ac.altP()),\n        \"Ctrl-Alt-P\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltP()),\n        \"Shift-Alt-P\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltP()),\n\n        \"Alt-A\": cm => this.astCapabilities(cm).then(ac => ac.altA()),\n        \"Ctrl-Alt-A\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltA()),\n        \"Shift-Alt-A\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltA()),\n        \"Alt-S\": cm => this.astCapabilities(cm).then(ac => ac.altS()),\n        \"Ctrl-Alt-S\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltS()),\n        \"Shift-Alt-S\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltS()),\n        \"Alt-D\": cm => this.astCapabilities(cm).then(ac => ac.altD()),\n        \"Ctrl-Alt-D\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltD()),\n        \"Shift-Alt-D\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltD()),\n        \"Alt-F\": cm => this.astCapabilities(cm).then(ac => ac.altF()),\n        \"Ctrl-Alt-F\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltF()),\n        \"Shift-Alt-F\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltF()),\n        \"Alt-G\": cm => this.astCapabilities(cm).then(ac => ac.altG()),\n        \"Ctrl-Alt-G\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltG()),\n        \"Shift-Alt-G\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltG()),\n        \"Alt-H\": cm => this.astCapabilities(cm).then(ac => ac.altH()),\n        \"Ctrl-Alt-H\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltH()),\n        \"Shift-Alt-H\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltH()),\n        \"Alt-J\": cm => this.astCapabilities(cm).then(ac => ac.altJ()),\n        \"Ctrl-Alt-J\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltJ()),\n        \"Shift-Alt-J\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltJ()),\n        \"Alt-K\": cm => this.astCapabilities(cm).then(ac => ac.altK()),\n        \"Ctrl-Alt-K\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltK()),\n        \"Shift-Alt-K\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltK()),\n        \"Alt-L\": cm => this.astCapabilities(cm).then(ac => ac.altL()),\n        \"Ctrl-Alt-L\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltL()),\n        \"Shift-Alt-L\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltL()),\n\n        \"Alt-Z\": cm => this.astCapabilities(cm).then(ac => ac.altZ()),\n        \"Ctrl-Alt-Z\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltZ()),\n        \"Shift-Alt-Z\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltZ()),\n        \"Alt-X\": cm => this.astCapabilities(cm).then(ac => ac.altX()),\n        \"Ctrl-Alt-X\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltX()),\n        \"Shift-Alt-X\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltX()),\n        \"Alt-C\": cm => this.astCapabilities(cm).then(ac => ac.altC()),\n        \"Ctrl-Alt-C\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltC()),\n        \"Shift-Alt-C\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltC()),\n        \"Alt-V\": cm => this.astCapabilities(cm).then(ac => ac.altV()),\n        \"Ctrl-Alt-V\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltV()),\n        \"Shift-Alt-V\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltV()),\n        \"Alt-B\": cm => this.astCapabilities(cm).then(ac => ac.altB()),\n        \"Ctrl-Alt-B\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltB()),\n        \"Shift-Alt-B\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltB()),\n        // \"Alt-N\": cm => this.astCapabilities(cm).then(ac => ac.altN()),\n        // \"Ctrl-Alt-N\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltN()),\n        // \"Shift-Alt-N\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltN()),\n        // \"Alt-M\": cm => this.astCapabilities(cm).then(ac => ac.altM()),\n        // \"Ctrl-Alt-M\": cm => this.astCapabilities(cm).then(ac => ac.ctrlAltM()),\n        // \"Shift-Alt-M\": cm => this.astCapabilities(cm).then(ac => ac.shiftAltM()),\n        \"Alt-N Alt-M\": cm => lively.notify('A Multistroke Shortcut!'),\n        // #KeyboardShortcut Alt-M ast refactoring/autocomplete menu\n        \"Alt-M\": cm => {\n          if(this.isJavaScript){\n            this.openContextMenu(cm);\n          } else {\n            lively.warn(\"Context Menu doesn't work outside of js files for now!\");\n          }\n        },\n        \n        // #KeyboardShortcut Ctrl-H search and replace\n        \"Insert\": (cm) => {\n          // do nothing... the INSERT mode is so often activated by accident \n        },\n        \"Ctrl-Insert\": (cm) => {\n          // INSERT mode is so often activated by accident, require CTRL now \n          cm.toggleOverwrite()\n        },\n        \"Ctrl-H\": (cm) => {\n          setTimeout(() => {\n              editor.execCommand(\"replace\");\n              this.shadowRoot.querySelector(\".CodeMirror-search-field\").focus();\n          }, 10)\n        },\n        // #KeyboardShortcut Ctrl-Space auto complete\n        \"Ctrl-Space\": cm => {\n          this.fixHintsPosition()\n          cm.execCommand(\"autocomplete\")\n        },\n        // #KeyboardShortcut Ctrl-Alt-Space auto complete\n        \"Ctrl-Alt-Space\": cm => {\n          this.fixHintsPosition()\n          cm.execCommand(\"autocomplete\")\n        },\n        // #KeyboardShortcut Ctrl-P eval and print selection or line\n        \"Ctrl-P\": (cm) => {\n            let text = this.getSelectionOrLine()\n            this.tryBoundEval(text, true);\n        },\n        // #KeyboardShortcut Ctrl-I eval and inspect selection or line\n        \"Ctrl-I\": (cm) => {\n          let text = this.getSelectionOrLine()\n          this.inspectIt(text)\n        },\n        // #KeyboardShortcut Ctrl-D eval selection or line (do it)\n        \"Ctrl-D\": (cm, b, c) => {\n            let text = this.getSelectionOrLine();\n            this.tryBoundEval(text, false);\n            return true\n        },\n        // #KeyboardShortcut Ctrl-F search\n        \"Ctrl-F\": (cm) => {\n          // something immediately grabs the \"focus\" and we close the search dialog..\n          // #Hack...\n          setTimeout(() => {\n                editor.execCommand(\"findPersistent\");\n                this.shadowRoot.querySelector(\".CodeMirror-search-field\").focus();\n          }, 10)\n          // editor.execCommand(\"find\")\n        },\n        \n        // #KeyboardShortcut Ctrl-Alt-Right multiselect next\n        \"Ctrl-Alt-Right\": \"selectNextOccurrence\",\n        // #KeyboardShortcut Ctrl-Alt-Left undo multiselect\n        \"Ctrl-Alt-Left\": \"undoSelection\",\n\n        // #KeyboardShortcut Ctrl-/ indent selection\n        \"Ctrl-/\": \"toggleCommentIndented\",\n        // #KeyboardShortcut Ctrl-# indent selection\n        \"Ctrl-#\": \"toggleCommentIndented\",\n        // #KeyboardShortcut Tab insert tab or soft indent\n        'Tab': (cm) => {\n          if (cm.somethingSelected()) {\n            cm.indentSelection(\"add\");\n          } else {\n            cm.execCommand('insertSoftTab')\n          }\n        },\n        // #KeyboardShortcut Ctrl-S save content\n        \"Ctrl-S\": (cm) => {\n          this.myASTCapabilities = undefined; // Reload our ASTCapabilities to improve workflow when changing code there\n          this.doSave(cm.getValue());\n        },\n        // #KeyboardShortcut Ctrl-Alt-V eval and open in vivide\n        \"Ctrl-Alt-V\": async cm => {\n          let text = this.getSelectionOrLine();\n          let result = await this.tryBoundEval(text, false);\n          letsScript(result);\n        },\n        // #KeyboardShortcut Ctrl-Alt-I show type using tern\n        \"Ctrl-Alt-I\": cm => {\n          this.ternWrapper.then(tw => tw.showType(cm, this));\n        },\n        // #KeyboardShortcut Alt-. jump to definition using tern\n        \"Alt-.\": cm => {\n          lively.notify(\"try to JUMP TO DEFINITION\")\n          this.ternWrapper.then(tw => tw.jumpToDefinition(cm, this));\n        },\n        // #KeyboardShortcut Alt-, jump back from definition using tern\n        \"Alt-,\": cm => {\n          this.ternWrapper.then(tw => tw.jumpBack(cm, this));\n        },\n        // #KeyboardShortcut Shift-Alt-. show references using tern\n        \"Shift-Alt-.\": cm => {\n          this.ternWrapper.then(tw => tw.showReferences(cm, this));\n        },\n\n        /*MD #AST-Navigation MD*/\n\n        // #KeyboardShortcut Alt-Up Expand selection in ast-aware manner\n        \"Alt-Up\": cm => {\n          this.astCapabilities(cm).then(ac => ac.expandSelection(cm));\n        },\n        // #KeyboardShortcut Alt-Down Reduce selection in ast-aware manner\n        \"Alt-Down\": cm => {\n          this.astCapabilities(cm).then(ac => ac.reduceSelection(cm));\n        },\n        // #KeyboardShortcut Alt-Shift-Up Select previous like this\n        \"Shift-Alt-Up\": cm => {\n          this.astCapabilities(cm).then(ac => ac.selectNextASTNodeLikeThis(true));\n        },\n        // #KeyboardShortcut Alt-Shift-Down Select next like this\n        \"Shift-Alt-Down\": cm => {\n          this.astCapabilities(cm).then(ac => ac.selectNextASTNodeLikeThis(false));\n        },\n\n        // #KeyboardShortcut Alt-Left Select previous element in ast-aware manner\n        \"Alt-Left\": cm => {\n          this.astCapabilities(cm).then(ac => ac.selectNextASTChild(true));\n        },\n        // #KeyboardShortcut Alt-Right Select next element in ast-aware manner\n        \"Alt-Right\": cm => {\n          this.astCapabilities(cm).then(ac => ac.selectNextASTChild(false));\n        },\n        // #KeyboardShortcut Alt-Shift-Left Select previous reference\n        \"Shift-Alt-Left\": cm => {\n          this.astCapabilities(cm).then(ac => ac.selectNextReference(true));\n        },\n        // #KeyboardShortcut Alt-Shift-Right Select next reference\n        \"Shift-Alt-Right\": cm => {\n          this.astCapabilities(cm).then(ac => ac.selectNextReference(false));\n        },\n\n        // #KeyboardShortcut Alt-J Jump to declaration of this identifier\n        \"Alt-J\": cm => {\n          this.astCapabilities(cm).then(ac => ac.selectDeclaration());\n        },\n        // #KeyboardShortcut Alt-R Rename this identifier\n        \"Alt-R\": cm => {\n          this.astCapabilities(cm).then(ac => ac.rename());\n        },\n        // #KeyboardShortcut Alt-Enter Toggle AST Mode\n        \"Alt-Enter\": cm => {\n          this.classList.toggle('ast-mode');\n        },\n        // #KeyboardShortcut Alt-I Inline variable\n        \"Alt-I\": cm => {\n          this.astCapabilities(cm).then(ac => ac.inlineLocalVariable());\n        },\n        // #KeyboardShortcut Alt-E Extract Expression into a local variable\n        \"Alt-E\": cm => {\n          this.astCapabilities(cm).then(ac => ac.extractExpressionIntoLocalVariable());\n        },\n        \n        // #KeyboardShortcut Alt-Backspace Leave Editor and go to Navigation\n        \"alt-Backspace\": async cm => {\n          this.singalEditorbackNavigation()\n        },\n        // #KeyboardShortcut Shift-Alt-Backspace Leave and Close Editor and go to Navigation\n        \"shift-alt-Backspace\": async cm => {\n          this.singalEditorbackNavigation(true)\n        },\n        // #KeyboardShortcut Shift-Alt-A show additional info of this Active Expression\n        \"Shift-Alt-A\": async cm => {\n          this.showAExprDependencyTextMarkers();\n        },\n        // #Async #Workspace #Snippet #Workaround missing global async/await support in JavaScript / our Workspaces\n        \"Ctrl-Alt-A\": cm => {\n          var selection = this.editor.getSelection()\n          // #TODO how can we have custom snippets?\n          this.editor.replaceSelection(`var value;\n(async () => {\n  value = ${selection}\n})()`)\n          this.editor.execCommand(`goWordLeft`)\n          this.editor.execCommand(`goCharLeft`)\n        },\n        // #KeyboardShortcut Ctrl-Shift-A Update Active Expression Dependencies\n        \"Ctrl-Shift-A\": cm => {\n          this.updateAExprDependencies();\n        },\n        \n        // #KeyboardShortcut Alt-Q sample shortcut for auto-completion\n        \"Alt-Q\": cm => {\n          this.autoCompletion(cm).then(ac => ac.complete(this, cm));\n        },\n  \n      }\n      \n    }\n    return this.extraKeys\n  }\n  \n  openContextMenu(cm) {\n    this.astCapabilities(cm).then(ac => {\n      openMenu(ac, cm, this);\n    });\n  }\n  \n  async singalEditorbackNavigation(closeEditor) {\n    var container = lively.query(this, \"lively-container\")\n    if (container) {\n      if (closeEditor) await container.onCancel()\n      await lively.sleep(10)\n      // it seems not to bubble across shadow root boundaries #Bug ?\n      // so we do it manually, but keep it an event\n      container.dispatchEvent(new CustomEvent(\"editorbacknavigation\", {\n        bubbles: true,\n        cancelable: true,\n      }))\n\n    }\n  }\n  \n  registerExtraKeys(options) {\n    if (options) this.addKeys(options)\n    var keys = {}\n    keys = Object.assign(keys, CodeMirror.keyMap.sublime)\n    keys = Object.assign(keys, this.ensureExtraKeys())\n    this.editor.setOption(\"extraKeys\", CodeMirror.normalizeKeyMap(keys));\n  }\n    \n  \n  setupEditorOptions(editor) {\n    editor.setOption(\"matchBrackets\", true)\n    editor.setOption(\"styleSelectedText\", true)\n    editor.setOption(\"autoCloseBrackets\", true)\n    editor.setOption(\"autoCloseTags\", true)\n\t\teditor.setOption(\"scrollbarStyle\", \"simple\")\n\t\teditor.setOption(\"scrollbarStyle\", \"simple\")\n    \n    editor.setOption(\"tabSize\", 2)\n    editor.setOption(\"indentWithTabs\", false)\n\n    editor.setOption(\"highlightSelectionMatches\", {showToken: /\\w/, annotateScrollbar: true})\n\n    // editor.setOption(\"keyMap\",  \"sublime\")\n\t\t\n    editor.on(\"cursorActivity\", cm => {\n      if (this.ternLoaded) {\n        this.ternWrapper.then(tw => tw.updateArgHints(cm, this))\n      }\n    });\n    \n    // http://bl.ocks.org/jasongrout/5378313#fiddle.js\n    editor.on(\"cursorActivity\", cm => {\n      // this.ternWrapper.then(tw => tw.updateArgHints(cm, this));\n      const widgetEnter = cm.widgetEnter;\n      cm.widgetEnter = undefined;\n      if (widgetEnter) {\n        // check to see if movement is purely navigational, or if it\n        // doing something like extending selection\n        var cursorHead = cm.getCursor('head');\n        var cursorAnchor = cm.getCursor('anchor');\n        if (posEq(cursorHead, cursorAnchor)) {\n          widgetEnter();\n        }\n      }\n    });\n    editor.setOption(\"hintOptions\", {\n      container: this.shadowRoot.querySelector(\"#code-mirror-hints\"),\n      codemirror: this,\n      closeCharacters: /\\;/ // we want to keep the hint open when typing spaces and \"{\" in imports...\n    });\n    \n    this.registerExtraKeys()\n  }\n\n  \n  \n  // Fires when an attribute was added, removed, or updated\n  attributeChangedCallback(attr, oldVal, newVal) {\n    if(!this.editor){\n        return false;\n    }\n    switch(attr){\n      // case \"theme\":\n      //     this.editor.setTheme( newVal );\n      //     break;\n      case \"mode\":\n          this.editor.setOption('mode', newVal);\n          break;\n      // case \"fontsize\":\n      //     this.editor.setFontSize( newVal );\n      //     break;\n      // case \"softtabs\":\n      //     this.editor.getSession().setUseSoftTabs( newVal );\n      //     break;\n      // case \"tern\":\n      //   if (newVal)\n      // this.enableTern()\n      //   break;\n\n      case \"tabsize\":\n\t\t\t\tthis.setOption(\"tabSize\", newVal)\n        break;\n      // case \"readonly\":\n      //     this.editor.setReadOnly( newVal );\n      //     break;\n      case \"wrapmode\":\n        this.setOption(\"lineWrapping\", newVal)\n        break;\n    }\n  }\n\n\n  setOption(name, value) {\n    if (!this.editor) return; // we loose...\n    this.editor.setOption(name, value)\n  }\n\n  doSave(text) {\n    this.tryBoundEval(text) // just a default implementation...\n  }\n\n  getSelectionOrLine() {\n    var text = this.editor.getSelection()\n    if (text.length > 0)\n      return text\n    else\n      return this.editor.getLine(this.editor.getCursor(\"end\").line)\n  }\n\n  getDoitContext() {\n    return this.doitContext\n  }\n\n  setDoitContext(context) {\n    return this.doitContext = context;\n  }\n\n  getTargetModule() {\n    // lazily initialize a target module name as fallback\n    return this.targetModule || (this.targetModule = lively4url +'/unnamed_module_' + generateUUID().replace(/-/g, '_')); // make it relative to a real path so that relative modules work\n  }\n\n  setTargetModule(module) {\n    return this.targetModule = module;\n  }\n\n  async boundEval(str) {\n    // console.log(\"bound eval \" + str)\n    var targetModule = this.getTargetModule()\n    \n    if(targetModule.match(/.py$/)) {\n      return this.boundEvalPython(str)\n    }\n    // Ensure target module loaded (for .js files only)\n    if(targetModule.match(/.js$/)) {\n      await System.import(targetModule)\n    }\n    console.log(\"EVAL (CM)\", targetModule);\n    // src, topLevelVariables, thisReference, <- finalStatement\n    return boundEval(str, this.getDoitContext(), targetModule);\n  }\n  \n  async boundEvalPython(str) {\n    var result = \"\"\n    var xterm = document.querySelector(\"lively-xterm.python\")\n    if (xterm) {\n      var term = xterm.term\n      term.__socket.addEventListener('message', function (event) {\n        result += event.data;\n      });\n      // how long do we want to wait?\n\n      term.__sendData(str + \"\\n\")\n\n      while(!result.match(\">>>\")) {\n        // busy wait for the prompt\n        await lively.sleep(50) \n      }\n      // strip input and prompt.... oh what a hack\n      return {value: result.replace(str,\"\").replace(/^[\\r\\n]+/,\"\").replace(/>>> $/,\"\")}     \n    } else {\n      lively.notify(\"no open python terminal session found\")\n    }\n    return {value: \"\"}\n  }\n\n  printWidget(name) {\n    return this.wrapWidget(name, this.editor.getCursor(true), this.editor.getCursor(false))\n  }\n\n  wrapWidget(name, from, to, options) {\n    var widget = document.createElement(\"span\");\n    widget.classList.add(\"lively-widget\")\n    widget.style.whiteSpace = \"normal\";\n    var promise = lively.create(name, widget);\n    promise.then(comp => {\n      Object.assign(comp.style, {\n        display: \"inline\",\n        // backgroundColor: \"rgb(250,250,250)\",\n        display: \"inline-block\",\n        minWidth: \"20px\",\n        minHeight: \"20px\"\n      });\n    });\n    // #TODO, we assume that it will keep the first widget, and further replacements do not work.... and get therefore thrown away\n    var marker = this.editor.doc.markText(from, to, Object.assign({\n      replacedWith: widget\n    }, options));\n    promise.then(comp => comp.marker = marker);\n\n    return promise;\n  }\n\n\n  async printResult(result, obj, isPromise) {\n    var editor = this.editor;\n    var text = result\n    var isAsync = false\n    this.editor.setCursor(this.editor.getCursor(\"end\"))\n    // don't replace existing selection\n    this.editor.replaceSelection(result, \"around\")\n    if (obj && obj.__asyncresult__) {\n      obj = obj.__asyncresult__; // should be handled in bound-eval.js #TODO\n      isAsync = true\n    }\n    var promisedWidget\n    var objClass = (obj && obj.constructor && obj.constructor.name) || (typeof obj)\n    if (isSet.call(obj)) {\n      obj = Array.from(obj)\n    }\n\n    if (_.isMap(obj)) {\n      var mapObj = {}\n      Array.from(obj.keys()).sort().forEach(key => mapObj[key] = obj.get(key))\n      obj = mapObj\n    }\n    if (Array.isArray(obj) && !obj.every(ea => ea instanceof Node)) {\n      if (obj.every(ea => (typeof ea == 'object') && !(ea instanceof String))) {\n        promisedWidget = this.printWidget(\"lively-table\").then( table => {\n          table.setFromJSO(obj)\n          table.style.maxHeight = \"300px\"\n          table.style.overflow = \"auto\"\n          return table\n        })\n      } else {\n        promisedWidget = this.printWidget(\"lively-table\").then( table => {\n          table.setFromJSO(obj.map((ea,index) => {\n            return {\n              index: index,\n              value: this.ensuredPrintString(ea)\n            }\n          }));\n          table.style.maxHeight = \"300px\";\n          table.style.overflow = \"auto\";\n          return table;\n        })\n      }\n    } else if(objClass ==  \"Matrix\") {\n      // obj = obj.toString()\n      debugger\n    } else if ((typeof obj == 'object') && (obj !== null)) {\n      promisedWidget = this.printWidget(\"lively-inspector\").then( inspector => {\n        inspector.inspect(obj)\n        inspector.hideWorkspace()\n        return inspector\n      })\n    }\n    if (promisedWidget) {\n        var widget = await promisedWidget;\n        var span = <span style=\"border-top:2px solid darkgray;color:darkblue\">\n          {isPromise ? \"PROMISED\" : \"\"} <u>:{objClass}</u> </span>\n        widget.parentElement.insertBefore(span, widget)\n        span.appendChild(widget)\n        if (isAsync && promisedWidget) {\n          if (widget) widget.style.border = \"2px dashed blue\"\n        }\n\n    }\n  }\n\n  ensuredPrintString(obj) {\n    var s = \"\";\n    try {\n      s += obj // #HACK some objects cannot be printed any more\n    } catch(e) {\n      s += `UnprintableObject[Error: ${e}]`; // so we print something else\n    }\n    return s\n  }\n  \n\n  async tryBoundEval(str, printResult) {\n    var resp = await this.boundEval(str);\n    if (resp.isError) {\n      var e = resp.value;\n      console.error(e);\n      if (printResult) {\n        window.LastError = e;\n        this.printResult(stripErrorString(\"\" + e));\n      } else {\n        lively.handleError(e);\n      }\n      return e;\n    }\n    var result = resp.value\n\n    if (printResult) {\n      // alaways wait on promises.. when interactively working...\n      if (result && result.then) { //  && result instanceof Promise\n        // we will definitly return a promise on which we can wait here\n        result\n          .then( result => {\n            this.printResult(\"RESOLVED: \" + this.ensuredPrintString(result), result, true)\n          })\n          .catch( error => {\n            console.error(error);\n            // window.LastError = error;\n            this.printResult(stripErrorString(\"Error in Promise: \\n\" +error))\n          })\n      } else {\n        this.printResult(\" \" + this.ensuredPrintString(result), result)\n        if (result instanceof HTMLElement ) {\n          try {\n            lively.showElement(result)\n          } catch(e) {\n            // silent fail... not everything can be shown...\n          }\n        }\n      }\n    }\n    return result\n  }\n\n  async inspectIt(str) {\n    var result =  await this.boundEval(str);\n    if (!result.isError) {\n      result = result.value\n    }\n    if (result.then) {\n      result = await result; // wait on any promise\n    }\n    lively.openInspector(result, undefined, str)\n  }\n\n\n  doSave(text) {\n    this.tryBoundEval(text) // just a default implementation...\n  }\n\n\n  detachedCallback() {\n    this._attached = false;\n  };\n\n  get value() {\n    if (this.editor) {\n      return this.editor.getValue()\n    } else {\n      return this._value\n    }\n  }\n\n  set value(text) {\n    if (this.editor) {\n      this.editor.setValue(text)\n    } else {\n      this._value = text\n    }\n  }\n\n  setCustomStyle(source) {\n    this.shadowRoot.querySelector(\"#customStyle\").textContent = source\n  }\n\n  getCustomStyle(source) {\n    return this.shadowRoot.querySelector(\"#customStyle\").textContent\n  }\n\n  encodeHTML(s) {\n    return s.replace(\"&\", \"&amp;\").replace(\"<\", \"&lt;\")\n  }\n\n  decodeHTML(s) {\n    return s.replace(\"&lt;\", \"<\").replace(\"&amp;\", \"&\")\n  }\n\n  resize() {\n    // #ACE Component compatiblity\n  }\n\n  enableAutocompletion() {\n    // #ACE Component compatiblity\n  }\n\n  get isJavaScript() {\n    if (!this.editor) return false;\n    let mode = this.editor.getOption(\"mode\");\n    return mode === \"javascript\" || mode === 'text/jsx';\n  }\n\n  get isMarkdown() {\n    if (!this.editor) return false;\n    return this.editor.getOption(\"mode\") == \"gfm\";\n  }\n\n  get isHTML() {\n    if (!this.editor) return false;\n    return this.editor.getOption(\"mode\") == \"text/html\";\n  }\n\n\n  async changeModeForFile(filename) {\n    if (!this.editor) return;\n\n    var mode = \"text\"\n    // #TODO there must be some kind of automatching?\n    if (filename.match(/\\.html$/)) {\n      mode = \"text/html\"\n    } else if (filename.match(/\\.md$/)) {\n      mode = \"gfm\"\n    } else if (filename.match(/\\.tex$/)) {\n      mode = \"text/x-stex\"\n    } else if (filename.match(/\\.css$/)) {\n      mode = \"css\"\n    } else if (filename.match(/\\.xml$/)) {\n      mode = \"xml\"\n    } else if (filename.match(/\\.json$/)) {\n      mode = \"javascript\"\n    } else if (filename.match(/\\.js$/)) {\n      mode = \"text/jsx\"\n    } else if (filename.match(/\\.mjs$/)) {\n      mode = \"text/jsx\"\n    } else if (filename.match(/\\.py$/)) {\n      mode = \"text/x-python\"\n    } else if (filename.match(/\\.c$/)) {\n      mode = \"text/x-csrc\"\n    } else if (filename.match(/\\.cpp$/)) {\n      mode = \"text/x-c++src\"\n    } else if (filename.match(/\\.h$/)) {\n      mode = \"text/x-c++src\"\n    } else if (filename.match(/\\.sh$/)) {\n      mode = \"text/x-sh\"\n    }\n    \n    \n    this.mode = mode\n    this.editor.setOption(\"mode\", mode)\n    if (mode == \"gfm\" || mode == \"text/x-stex\") {\n      // #TODO make language customizable\n      var m = this.value.match(/^.*lang\\:(.._..)/)\n      if (m) {\n        var lang = m[1]\n        var dict = await spellCheck.loadDictLang(lang)\n        if (dict) {\n          lively.notify(\"start spell checking lang: \" + lang)\n          spellCheck.startSpellCheck(this.editor, dict)\n        } else {\n          console.log(\"spellchecking language not found: \" + lang)\n        }\n      } else {\n        spellCheck.startSpellCheck(this.editor, await spellCheck.current())\n      }\n    }\n\n  }\n\n  livelyPrepareSave() {\n    if(!this.editor) { return; }\n    this.textContent = this.encodeHTML(this.editor.getValue())\n  }\n\n  livelyPreMigrate() {\n    if (this.editor) {\n      this.lastScrollInfo = this.editor.getScrollInfo(); // #Example #PreserveContext\n    }\n  }\n\n  focus() {\n    if(this.editor) this.editor.focus()\n  }\n\n  isFocused(doc) {\n    doc = doc || document\n    if (doc.activeElement === this) return true\n    // search recursively in shadowDoms\n    if (doc.activeElement && doc.activeElement.shadowRoot) {\n\t\t\treturn this.isFocused(doc.activeElement.shadowRoot)\n    }\n    return false\n  }\n\n  async livelyMigrate(other) {\n    lively.addEventListener(\"Migrate\", this, \"editor-loaded\", evt => {\n      if (evt.composedPath()[0] !== this) return; // bubbled from another place... that is not me!\n      lively.removeEventListener(\"Migrate\", this, \"editor-loaded\") // make sure we migrate only once\n      this.value = other.value;\n      if (other.lastScrollInfo) {\n        this.editor.scrollTo(other.lastScrollInfo.left, other.lastScrollInfo.top)\n      }\n    })\n  }\n\n  fixHintsPosition() {\n    lively.setPosition(this.shadowRoot.querySelector(\"#code-mirror-hints\"),\n  pt(-document.scrollingElement.scrollLeft,-document.scrollingElement.scrollTop).subPt(lively.getGlobalPosition(this)))\n  }\n\n\n//   async enableTern() {\n//     await LivelyCodeMirror.loadTernModules()\n\n//     var ecmascriptdefs = await fetch(lively4url + \"/src/external/tern/ecmascript.json\").then(r => r.json())\n//     var browserdefs = await fetch(lively4url + \"/src/external/tern/browser.json\").then(r => r.json())\n//     // var chaidefs = await fetch(lively4url + \"/src/external/tern/chai.json\").then(r => r.json())\n\n//     // Options supported (all optional):\n//     // * defs: An array of JSON definition data structures.\n//     // * plugins: An object mapping plugin names to configuration\n//     //   options.\n//     // * getFile: A function(name, c) that can be used to access files in\n//     //   the project that haven't been loaded yet. Simply do c(null) to\n//     //   indicate that a file is not available.\n//     // * fileFilter: A function(value, docName, doc) that will be applied\n//     //   to documents before passing them on to Tern.\n//     // * switchToDoc: A function(name, doc) that should, when providing a\n//     //   multi-file view, switch the view or focus to the named file.\n//     // * showError: A function(editor, message) that can be used to\n//     //   override the way errors are displayed.\n//     // * completionTip: Customize the content in tooltips for completions.\n//     //   Is passed a single argument the completion's data as returned by\n//     //   Tern and may return a string, DOM node, or null to indicate that\n//     //   no tip should be shown. By default the docstring is shown.\n//     // * typeTip: Like completionTip, but for the tooltips shown for type\n//     //   queries.\n//     // * responseFilter: A function(doc, query, request, error, data) that\n//     //   will be applied to the Tern responses before treating them\n\n//     // It is possible to run the Tern server in a web worker by specifying\n//     // these additional options:\n//     // * useWorker: Set to true to enable web worker mode. You'll probably\n//     //   want to feature detect the actual value you use here, for example\n//     //   !!window.Worker.\n//     // * workerScript: The main script of the worker. Point this to\n//     //   wherever you are hosting worker.js from this directory.\n//     // * workerDeps: An array of paths pointing (relative to workerScript)\n//     //   to the Acorn and Tern libraries and any Tern plugins you want to\n//     //   load. Or, if you minified those into a single script and included\n//     //   them in the workerScript, simply leave this undefined.\n\n//     this.ternServer = new CodeMirror.TernServer({\n//       defs: [ecmascriptdefs, browserdefs], // chaidefs\n//       plugins: {\n//         es_modules: {}\n//       },\n//       getFile: (name, c) => {\n//         lively.notify(\"get file \" + name)\n//         c(null)\n//       },\n//       // responseFilter: (doc, query, request, error, data) => {\n//       //  return data\n//       // }\n\n//     });\n\n//     this.editor.setOption(\"extraKeys\", Object.assign({},\n//       this.editor.getOption(\"extraKeys\"),\n//       {\n//         \"Ctrl-Space\": (cm) => {\n//           this.fixHintsPosition();\n//           this.ternServer.complete(cm);\n//         },\n//         \"Ctrl-Alt-I\": (cm) => { this.ternServer.showType(cm); },\n//         \"Ctrl-O\": (cm) => { this.ternServer.showDocs(cm); },\n//         \"Alt-.\": (cm) => { this.ternServer.jumpToDef(cm); },\n//         \"Alt-,\": (cm) => { this.ternServer.jumpBack(cm); },\n//         \"Ctrl-Q\": (cm) => { this.ternServer.rename(cm); },\n//         \"Ctrl-.\": (cm) => { this.ternServer.selectName(cm); }\n//       }))\n\n//     this.editor.on(\"cursorActivity\", (cm) => { this.ternServer.updateArgHints(cm); });\n//   }\n\n\n  async addTernFile(name, url, text) {\n    if (!this.ternServer) return\n    url = url || name;\n    text = text || await fetch(url).then(r => r.text())\n    this.ternServer.server.addFile(name, text)\n  }\n\n  mergeView(originalText, originalLeftText) {\n    debugger\n    var target = this.shadowRoot.querySelector(\"#code-mirror-container\")\n    target.innerHTML = \"\";\n    this._mergeView =  CodeMirror.MergeView(target, {\n      value: this.value,\n      origLeft: originalLeftText,\n      orig: originalText,\n      lineNumbers: true,\n      mode: this.editor.getOption('mode'),\n      scrollbarStyle: this.editor.getOption('scrollbarStyle'),\n      highlightDifferences: true,\n      connect: \"align\",\n      lineWrapping: true,\n      collapseIdentical: false\n    });\n    // if (this._mergeView.right) {\n    // this.setEditor(this._mergeView.right.edit)\n    // }\n    this.setEditor(this._mergeView.editor())\n    // this.resizeMergeView(this._mergeView)\n  }\n\n  resizeMergeView(mergeView) {\n    function editorHeight(editor) {\n      if (!editor) return 0;\n      return editor.getScrollInfo().height;\n    }\n\n    function mergeViewHeight(mergeView) {\n      return Math.max(editorHeight(mergeView.leftOriginal()),\n                      editorHeight(mergeView.editor()),\n                      editorHeight(mergeView.rightOriginal()));\n    }\n    var height = mergeViewHeight(mergeView);\n    for(;;) {\n      if (mergeView.leftOriginal())\n        mergeView.leftOriginal().setSize(null, height);\n      mergeView.editor().setSize(null, height);\n      if (mergeView.rightOriginal())\n        mergeView.rightOriginal().setSize(null, height);\n\n      var newHeight = mergeViewHeight(mergeView);\n      if (newHeight >= height) break;\n      else height = newHeight;\n    }\n    mergeView.wrap.style.height = height + \"px\";\n  }\n\n  async hideDataURLs() {\n    var regEx = new RegExp(\"[\\\"\\'](data:[^\\\"\\']*)[\\\"\\']\", \"g\");\n    do {\n      var m = regEx.exec(this.value);\n      if (m) {\n        var from = m.index\n        var to = m.index + m[0].length\n        await this.wrapWidget(\"span\", this.editor.posFromIndex(from),\n                              this.editor.posFromIndex(to)).then( div => {\n          div.style.backgroundColor = \"rgb(240,240,240)\"\n\n          if (m[1].match(/^data:image/)) {\n            var img = document.createElement(\"img\")\n            img.src = m[1]\n            img.title = m[1].slice(0,50) + \"...\"\n            img.style.maxHeight = \"100px\"\n\n            div.appendChild(document.createTextNode(\"\\\"\"))\n            div.appendChild(img)\n            div.appendChild(document.createTextNode(\"\\\"\"))\n          } else {\n            div.innerHTML = \"\\\"\"+ m[1].slice(0,50) + \"...\" + \"\\\"\"\n          }\n        })\n\n      }\n    } while (m);\n  }\n\n//    async wrapImageLinks() {\n//     var regEx = new RegExp(\"\\!\\[\\]\\(([A-Za-z0-9_ .]\\.((jpg)|(png)))$\\)\", \"g\");\n//     do {\n//       var m = regEx.exec(this.value);\n//       if (m) {\n//         var from = m.index\n//         var to = m.index + m[0].length\n//         var url = m[1]\n//         await this.wrapWidget(\"span\", this.editor.posFromIndex(from),\n//                               this.editor.posFromIndex(to)).then( div => {\n//           div.style.backgroundColor = \"rgb(240,240,240)\"\n\n//           if (m[1].match(/^data:image/)) {\n//             var img = document.createElement(\"img\")\n//             img.src = m[1]\n//             img.title = m[1].slice(0,50) + \"...\"\n//             img.style.maxHeight = \"100px\"\n\n//             div.appendChild(document.createTextNode(\"\\\"\"))\n//             div.appendChild(img)\n//             div.appendChild(document.createTextNode(\"\\\"\"))\n//           } else {\n//             div.innerHTML = \"\\\"\"+ m[1].slice(0,50) + \"...\" + \"\\\"\"\n//           }\n//         })\n\n//       }\n//     } while (m);\n//   }\n\n\n  async wrapImports() {\n    // dev mode alternative to #DevLayers, a #S3Pattern: add code the scopes your dev example inline while developing\n    if(this.id !== 'spike') {\n      // lively.warn('skip because id is not spike')\n      return;\n    }\n    // lively.success('wrap imports in spike')\n\n    const getImportDeclarationRegex = () => {\n      const LiteralString = `([\"][^\"\\\\n\\\\r]*[\"]|['][^'\\\\n\\\\r]*['])`;\n      const JavaScriptIdentifier = '([a-zA-Z$_][a-zA-Z0-9$_]*)'\n\n      const ImportSpecifierPartSimple = `(${JavaScriptIdentifier})`;\n      const ImportSpecifierPartRename = `(${JavaScriptIdentifier}\\\\s+as\\\\s+${JavaScriptIdentifier})`;\n      const ImportSpecifierPart = `(${ImportSpecifierPartSimple}|${ImportSpecifierPartRename})`;\n      // ImportSpecifier: {foo} or {foo as bar}\n      const ImportSpecifier = `({\\\\s*((${ImportSpecifierPart}\\\\s*\\\\,\\\\s*)*${ImportSpecifierPart}\\\\,?)?\\\\s*})`;\n      // ImportDefaultSpecifier: foo\n      const ImportDefaultSpecifier = `(${JavaScriptIdentifier})`;\n      // ImportNamespaceSpecifier: * as foo\n      const ImportNamespaceSpecifier = `(\\\\*\\\\s*as\\\\s+${JavaScriptIdentifier})`;\n      const anySpecifier = `(${ImportSpecifier}|${ImportDefaultSpecifier}|${ImportNamespaceSpecifier})`;\n      // ImportDeclaration: import [any] from Literal\n      const ImportDeclaration = `import\\\\s*(${anySpecifier}\\\\s*\\\\,\\\\s*)*${anySpecifier}\\\\s*from\\\\s*${LiteralString}(\\\\s*\\\\;)?`;\n\n      return ImportDeclaration;\n    };\n\n    var regEx = new RegExp(getImportDeclarationRegex(), 'g');\n\n    do {\n      var m = regEx.exec(this.value);\n      if (m) {\n        await LivelyCodeMirrorWidgetImport.importWidgetForRange(this, m);\n      }\n    } while (m);\n  }\n\n   async wrapLinks() {\n    // dev mode\n    if(this !== window.that) {\n      return;\n    }\n    var regEx = new RegExp(\"\\<([a-zA-Z0-9]+\\:\\/\\/[^ ]+)\\>\", \"g\");\n    do {\n      var m = regEx.exec(this.value);\n      if (m) {\n        lively.warn(\"wrap link: \" + m[0])\n        var from = m.index\n        var to = m.index + m[0].length\n        var link = m[1]\n        // #TODO check for an existing widget and reuse / update it...\n        await this.wrapWidget(\"span\", this.editor.posFromIndex(from),\n                              this.editor.posFromIndex(to)).then(widget => {\n          window.lastWidget = widget\n\n          widget.style.backgroundColor = \"rgb(120,120, 240)\"\n          var input = <input></input>\n          input.value = m[0]\n\n          lively.warn(\"new input \" + input)\n\n\n          input.addEventListener(\"keydown\", evt => {\n            var range = widget.marker.find()\n            if (evt.keyCode == 13) { // ENTER\n              // #TODO how to replace // update text without replacing widgets\n              this.editor.replaceRange(input.value, range.from, range.to) // @Stefan, your welcome! ;-)\n              this.wrapLinks() // don't wait and do what you can now\n            }\n            if (evt.keyCode == 37) { // Left\n              if (input.selectionStart == 0) {\n                this.editor.setSelection(range.from, range.from)\n                this.focus()\n              }\n            }\n\n            if (evt.keyCode == 39) { // Right\n              if (input.selectionStart == input.value.length) {\n                this.editor.setSelection(range.to, range.to)\n                this.focus()\n              }\n            }\n          })\n\n          widget.appendChild(input)\n          // widget.appendChild(<button click={e => {\n          //   lively.openBrowser(link)  // #TODO fix browse and open browser...\n          // }}>browse</button>)\n        })\n\n      }\n    } while (m);\n  }\n\n  checkSyntax() {\n    if (this.isJavaScript) {\n      SyntaxChecker.checkForSyntaxErrors(this.editor);\n      this.wrapImports();\n      this.wrapLinks();\n    }\n    if (this.isMarkdown || this.isHTML) {\n      this.hideDataURLs()\n    }\n  }\n\n\n  find(str) {\n    // #TODO this is horrible... Why is there not a standard method for this?\n\tif (!this.editor) return;\n    var found = false;\n    this.value.split(\"\\n\").forEach((ea, index) => {\n      var startPos = ea.indexOf(str)\n      if (!found && (startPos != -1)) {\n        this.editor.setCursor(index + 20, 10000);// line end ;-)\n        this.editor.focus()\n        this.editor.setSelection({line: index, ch: startPos }, {line: index, ch: startPos + str.length})\n        found = ea;\n      }\n    })\n  }\n  \n  scrollToLine(line) { \n    this.editor.scrollTo(null, this.editor.heightAtLine(line - 1, \"local\"));\n  }\n\n  unsavedChanges() {\n    if (this.editor.getValue() === \"\") return false\n    return  true // workspaces should be treated carefully\n   }\n\n  onCursorActivity() {\n    var container = lively.query(this, \"lively-container\")\n    if (!container) return;\n    var navbar = lively.query(this, \"lively-container-navbar\")\n    if (!navbar) return;\n      navbar.onDetailsContentCursorActivity(this.editor, \n        this.editor.getCursor(\"start\"), this.editor.getCursor(\"end\"))\n    }\n\n    livelyMinimizedTitle() {\n      return this.value.slice(0,80)\n    }\n  \n  /*MD ## Active Expression Support MD*/\n  async updateAExprDependencies() {\n    await this.editor;\n    const capabilities = await this.astCapabilities(this.editor);\n    if (!capabilities.canParse || !capabilities.hasActiveExpressionsDirective) {\n      this.hideAExprDependencyGutter();\n      this.resetAExprTextMarkers();\n      this.resetAExprDependencyTextMarkers();\n      return;\n    }\n    this.showAExprTextMarkers();\n    await this.showAExprDependencyGutter();\n    this.showAExprDependencyGutterMarkers();\n  }\n\n  async showAExprTextMarkers() {\n    const editor = await this.editor;\n    await this.resetAExprTextMarkers();\n    const capabilities = await this.astCapabilities(this.editor);\n    capabilities.getAllActiveExpressions().forEach(path => {\n      const r = range(path.node.loc).asCM();\n      const mark = this.editor.markText(r[0], r[1], {\n        css: \"background-color: #3BEDED\",\n      });\n      mark.isAExprTextMarker = true;\n    })\n  }\n\n  async resetAExprTextMarkers() {\n    const editor = await this.editor;\n    editor.getAllMarks().forEach(mark => {\n      if (mark.isAExprTextMarker) {\n        mark.clear();\n      }\n    });\n  }\n\n  async showAExprDependencyGutter() {\n    const id = \"activeExpressionGutter\";\n    const editor = await this.editor;\n    let gutters = editor.getOption(\"gutters\");\n    if (!gutters.some(marker => marker === id)) {\n      editor.setOption('gutters', [...gutters, id]);\n    };\n  }\n  \n  async hideAExprDependencyGutter() {\n    const id = \"activeExpressionGutter\";\n    const editor = await this.editor;\n    let gutters = editor.getOption(\"gutters\");\n    gutters = gutters.filter(marker => marker !== id);\n    editor.setOption('gutters', gutters);\n  }\n\n  async resetAExprDependencyTextMarkers() {\n    const editor = await this.editor;\n    editor.getAllMarks().forEach(mark => {\n      if (mark.isAExprDependencyTextMarker) {\n        mark.clear();\n      }\n    });\n  }\n\n  async showAExprDependencyTextMarkers() {\n    await this.editor;\n    await this.resetAExprDependencyTextMarkers();\n    const cursor = this.editor.getCursor();\n    const capabilities = await this.astCapabilities(this.editor);\n    const aexprPath = capabilities.getAexprAtCursor(cursor);\n    if (!aexprPath) return;\n    const deps = capabilities.resolveDependencies(aexprPath.get(\"arguments\")[0]);\n    deps.forEach((path) => {\n      const r = range(path.node.loc).asCM();\n      const mark = this.editor.markText(r[0], r[1], {\n        css: \"background-color: orange\",\n      });\n      mark.isAExprDependencyTextMarker = true;\n    });\n  }\n  \n  async showAExprDependencyGutterMarkers() {\n    const dict = new Map();\n    const lines = [];\n    \n    await this.editor;\n    const capabilities = await this.astCapabilities(this.editor);\n    capabilities.getAllActiveExpressions().forEach(path => {\n      const dependencies = capabilities.resolveDependencies(path.get(\"arguments\")[0]);\n\n      dependencies.forEach(statement => {\n        if (!dict.get(statement)) {\n          dict.set(statement, []);\n        }\n        dict.get(statement).push(path);\n      });\n    });\n  \n    for (const [statement,aExprs] of dict.entries()){\n      const line = statement.node.loc.start.line - 1; \n      if (!lines[line]) {\n        lines[line] = [];\n      }\n      for (let aExpr of aExprs ){\n        lines[line].push(aExpr);\n      }\n    }\n    \n    this.editor.doc.clearGutter('activeExpressionGutter');\n    lines.forEach((deps, line) => {\n      this.drawAExprGutter(line, deps);\n    })\n  }\n  \n  drawAExprGutter(line, dependencies) {\n    this.editor.doc.setGutterMarker(\n      line,\n      'activeExpressionGutter',\n      this.drawAExprGutterMarker(dependencies));\n  }\n\n  drawAExprGutterMarker(dependencies) {\n    const callback = async (evt) => {\n      const list = this.drawAExprDependencyList(dependencies);\n      const depListWrap = <div class=\"aexprDependencies\"></div>;\n      depListWrap.append(list);\n      this.prepend(depListWrap);\n      \n      depListWrap.style.height = \"100px\";\n      depListWrap.style.width = \"100px\";\n      const padding = 5;\n      const markerBounds = evt.target.getBoundingClientRect();\n      const wrapBounds = depListWrap.getBoundingClientRect();\n      console.error(markerBounds, wrapBounds);\n      console.error(evt.target, depListWrap);\n      const top = markerBounds.top - (wrapBounds.height + padding);\n      console.error(`${markerBounds.top} - ${wrapBounds.height + padding} === ${top}`);\n      depListWrap.style.top = `${top}px`;\n      depListWrap.style.right = `${markerBounds.left}px`;\n    }\n    \n    // TODO render this without the \"0\"\n    return <div class=\"activeExpressionGutter-marker\" click={callback}>\n      {dependencies.length}\n    </div>\n  }\n\n  drawAExprDependencyList(dependencies) {\n    const list = <div style=\"display:flex;flex-direction:column;width:fit-content;height:fit-content;\"></div>;\n    dependencies.forEach(dep => {\n      const state = dep.get(\"arguments.0.body\").getSource();\n      const line = dep.node.loc.start.line;\n      const description = `${line} : ${state}`;\n      const item = <div style=\"width:fit-content;height:fit-content;\">{description}</div>;\n      list.append(item);\n    });\n\n    return list;\n  }\n}"}