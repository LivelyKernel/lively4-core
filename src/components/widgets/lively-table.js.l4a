{"type":"Reference","version":"99781a38a42b1d5730f9846d8c1590a17b10c7aa","content":"\"enable aexpr\"\n\nimport Morph from 'src/components/widgets/lively-morph.js';\nimport ContextMenu from 'src/client/contextmenu.js';\nimport DragBehavior from \"src/client/morphic/dragbehavior.js\";\nimport aexpr from 'active-expression-rewriting';\nimport _ from 'src/external/lodash/lodash.js'\n\nexport default class LivelyTable extends Morph {\n\n  static create() {\n    // return Object.create(LivelyTable.prototype, {})\n    return document.createElement(\"lively-table\");\n  }\n\n  initialize() {\n    this.addEventListener(\"click\", evt => this.onClick(evt));\n    this.setAttribute(\"tabindex\", 0)\n    lively.html.registerKeys(this, \"Table\");\n    this.addEventListener(\"mousedown\", evt => this.onMouseDown(evt));\n    this.addEventListener(\"copy\", evt => this.onCopy(evt));\n    this.addEventListener(\"cut\", evt => this.onCut(evt));\n    this.addEventListener(\"paste\", evt => this.onPaste(evt));\n\n    this.addEventListener(\"focus\", evt => this.onFocus(evt));\n    this.addEventListener(\"focusout\", evt => this.onFocusout(evt));\n\n    this.addEventListener(\"extent-changed\", evt => this.onExtentChanged(evt));\n    this.addEventListener('contextmenu', evt => this.onContextMenu(evt), false);\n    \n    this.activeExpression = {};\n  }\n\n  /*MD ## Rows, Columns, Cells MD*/\n  \n  isCell(cell) {\n    return cell.tagName == \"TD\" || cell.tagName == \"TH\";\n  }  \n\n  rows() {\n    return Array.from(this.querySelectorAll(\"tr\"));\n  }\n\n  column(indexOrLabel) {\n    var index;\n    if (Number.isInteger(indexOrLabel)) {\n      index = indexOrLabel;\n    } else {\n      index = this.header().indexOf(indexOrLabel);\n      if (index == -1) return undefined;\n    }\n    return this.cells().map(row => row[index]);\n  }\n\n cells() {\n    return this.rows().map(ea => this.cellsIn(ea));\n  }\n\n  cellsIn(row) {\n    return Array.from(row.querySelectorAll(\"td,th\"));\n  }\n\n  cellAt(columnIndex, rowIndex) {\n    var row = this.rows()[rowIndex];\n    if (!row) return undefined;\n    return row.querySelectorAll(\"td,th\")[columnIndex];\n  }\n\n  columnOfCell(cell) {\n    return this.cellsIn(cell.parentElement).indexOf(cell);\n  }\n\n  rowOfCell(cell) {\n    var row = cell.parentElement;\n    return this.rows().indexOf(row);\n  }\n \n  // #private\n  initailizeCells(element) {\n    let rows = this.rows(),\n        row = element.parentElement,\n        rowCells = this.cellsIn(row);\n    return {\n      rows,\n      row,\n      rowCells\n    };\n  }\n  \n  keyForCell(cell) {\n    return this.cells()[0][this.columnOfCell(cell)].textContent;\n  }\n\n  header() {\n    return this.asArray()[0];\n  }\n  /*MD ## Selection MD*/\n  \n  selectCell(element, multipleSelection) {\n    if (!this.isCell(element)) return;\n    if (this.currentCell && this.currentCell != element) {\n      this.currentCell.contentEditable = false;\n      if (!multipleSelection) this.currentCell.classList.remove(\"table-selected\");\n    }\n    if (!element.parentElement) return; // cell must be one of mine\n\n    this.currentCell = element;\n    const {\n      rows,\n      row,\n      rowCells\n    } = this.initailizeCells(element);\n    \n    if (this.currentRow) {\n      this.currentRow.classList.remove('current')\n    }\n    this.currentRow = row;\n    this.currentRow.classList.add('current')\n    \n    this.currentRowIndex = rows.indexOf(row);\n    this.currentColumnIndex = rowCells.indexOf(element);\n    this.currentColumn = rows.map(ea => ea[this.currentColumnIndex]);\n\n    this.selectCellPrivate(multipleSelection, rows, row, rowCells, element);\n    \n    this.dispatchEvent(new CustomEvent(\"cell-selected\"))\n    \n  }\n  \n  // #private\n  selectCellPrivate(multipleSelection, rows, row, rowCells, element) {\n    if (multipleSelection) {\n      this.addSelectedCell(this.currentCell);\n    } else {\n      if (this.selectedCells) this.selectedCells.forEach(ea => {\n        ea.classList.remove(\"start-selection\");\n        ea.classList.remove(\"table-selected\");\n      });\n      this.selectedCells = [this.currentCell];\n      this.currentCell.classList.add(\"table-selected\");\n      this.startCell = this.currentCell;\n      this.startRowIndex = rows.indexOf(row);\n      this.startColumnIndex = rowCells.indexOf(element);\n      this.startCell.classList.add(\"start-selection\");\n    }\n  }\n\n  selectRow(rowIndex, multiselection) {\n    if (!multiselection) {\n      this.clearSelection();\n    }\n    this.cells()[rowIndex].forEach(cell => {\n      this.selectCell(cell, true);\n    });\n  }\n\n  selectColumn(columnIndex, multiselection) {\n    if (!multiselection) {\n      this.clearSelection();\n    }\n    this.cells().forEach(row => {\n      this.selectCell(row[columnIndex], true);\n    });\n  }\n\n  changeSelection(columnDelta, rowDelta, removeSelection) {\n    let columnA = this.startColumnIndex,\n        columnB = this.currentColumnIndex + columnDelta,\n        rowA = this.startRowIndex,\n        rowB = this.currentRowIndex + rowDelta;\n    this.changeSelectionBetween(columnA, columnB, rowA, rowB, removeSelection);\n  }\n\n  changeSelectionBetween(columnA, columnB, rowA, rowB, removeSelection) {\n    var cells = this.cells(),\n        columnMin = Math.min(columnA, columnB),\n        columnMax = Math.max(columnA, columnB),\n        rowMin = Math.min(rowA, rowB),\n        rowMax = Math.max(rowA, rowB);\n\n    for (var rowIndex = rowMin; rowIndex <= rowMax; rowIndex++) {\n      var row = cells[rowIndex];\n\n      if (row) {\n        // lively.notify(\"change selection \" + columnMin + \" \" + columnMax)\n\n        for (var columnIndex = columnMin; columnIndex <= columnMax; columnIndex++) {\n          var cell = row[columnIndex];\n          // lively.showElement(cell)\n          if (cell) {\n            if (removeSelection) {\n              this.removeSelectedCell(cell);\n            } else {\n              this.addSelectedCell(cell);\n            }\n          }\n        }\n      }\n    }\n\n    this.dispatchEvent(new CustomEvent(\"selection-changed\", { detail: { table: this } }));\n  }\n\n  navigateRelative(columnDelta, rowDelta, multipleSelection) {\n    if (this.currentColumnIndex === undefined) return;\n    var cells = this.cells();\n    if (multipleSelection) {\n      this.changeSelection(-columnDelta, -rowDelta, true);\n\n      this.changeSelection(columnDelta, rowDelta);\n    }\n    var row = cells[this.currentRowIndex + rowDelta];\n    if (!row) return;\n    var newCell = row[this.currentColumnIndex + columnDelta];\n\n    if (newCell) {\n      this.selectCell(newCell, multipleSelection);\n    }\n  }\n\n  setTextSelectionOfCellContents(cell) {\n    var range = document.createRange();\n    var sel = window.getSelection();\n    try {\n      // #TODO find a more correct way to set selection.... \n      range.setStart(cell, 0);\n      // I have problems setting this to the end... so lets go as far as we can in small steps\n      for (var i = 0; i <= cell.textContent.length; i++) {\n        range.setStart(cell, i);\n      }\n    } catch (e) {\n      // do nothing..\n    }\n    range.collapse(true);\n    sel.removeAllRanges();\n    sel.addRange(range);\n  }\n  \n  clearAllSelection() {\n    this.querySelectorAll(\"td\").forEach(ea => {\n      ea.classList.remove(\"editing\");\n      ea.removeAttribute(\"contentEditable\"\n      // ea.contentEditable = false\n\n      );\n    });\n  }\n\n\n  \n  \n  clearSelection(doNotClearStart) {\n    if (this.currentCell) {\n      this.currentCell.removeAttribute(\"contentEditable\");\n      this.currentCell.classList.remove(\"table-selected\");\n    }\n    if (!doNotClearStart) {\n      this.currentCell = undefined;\n      this.currentRow = undefined;\n      this.currentRowIndex = undefined;\n      this.currentColumnIndex = undefined;\n      this.currentColumn = undefined;\n      this.startCell = undefined;\n      this.startRowIndex = undefined;\n      this.startColumnIndex = undefined;\n    }\n\n    this.querySelectorAll(\"td,th\").forEach(ea => {\n      ea.classList.remove(\"table-selected\");\n      ea.classList.remove(\"start-selection\");\n    });\n\n    this.selectedCells = [];\n  }\n\n  addSelectedCell(element) {\n    if (!this.selectedCells) this.selectedCells = [];\n    if (this.selectedCells.indexOf(element) < 0) {\n      this.selectedCells.push(element);\n    }\n    element.classList.add(\"table-selected\");\n  }\n\n  removeSelectedCell(element) {\n    if (!this.selectedCells) this.selectedCells = [];\n    this.selectedCells.push(element);\n    this.selectedCells = this.selectedCells.filter(ea => ea !== element);\n    element.classList.remove(\"table-selected\");\n  }\n  \n  \n  /*MD ## Focus MD*/\n  \n  onContextMenu(evt) {\n    if (!evt.shiftKey) {\n      evt.stopPropagation();\n      evt.preventDefault();\n      var menu = new ContextMenu(this, [[\"add column\", () => this.insertColumnAt(this.currentColumnIndex)], [\"remove column\", () => this.removeColumnAt(this.currentColumnIndex)], [\"add row\", () => this.insertRowAt(this.currentRowIndex)], [\"remove row\", () => this.removeRowAt(this.currentRowIndex)]]);\n      menu.openIn(document.body, evt, this);\n      return true;\n    }\n  }\n\n  onExtentChanged() {\n    var table = this.get(\"table\");\n    lively.setWidth(table, lively.getExtent(this).x);\n    lively.setHeight(this, lively.getExtent(table).y, true);\n  }\n\n  async onFocusout() {\n    // we are about to lose our focus lets wait a bit\n    await lively.sleep(0\n    // if we really lost our focus... \n    );if (!this.isInFocus()) {\n      this.classList.remove(\"active\");\n    }\n  }\n\n  onFocus() {\n    if (this.isInFocus()) {\n      this.classList.add(\"active\");\n    }\n  }\n  \n  setFocusAndTextSelection(element) {\n    if (!element) return;\n    this.clearAllSelection();\n    // element.contentEditable = true;\n    element.focus();\n    var sel = window.getSelection();\n    // sel.selectAllChildren(element)    \n  }\n  /*MD ## Keyboard Events MD*/\n  \n  // #important\n  onEnterDown(evt) {\n\n    if (!this.currentCell) return;\n    var cell = this.currentCell\n    var wasEditing = this.isInEditing(cell);\n\n    if (wasEditing) {\n      this.currentCell.contentEditable = false\n      this.focus()\n\n      this.stopEditingCurrentCell()\n    } else {\n      this.startEditingCurrentCell()\n    }\n    \n    \n     \n    \n    evt.stopPropagation();\n    evt.preventDefault();\n  }\n\n  onEscDown(evt) {\n    if (!this.currentCell) return;\n    this.setFocusAndTextSelection(this.currentCell);\n    evt.stopPropagation();\n    evt.preventDefault();\n  }\n\n  isInEditing(cell) {\n    return cell.classList.contains(\"editing\");\n  }\n\n  handleArrowKey(evt, deltaColumn, deltaRow) {\n    if (this.isInEditing(this.currentCell)) return;\n    this.navigateRelative(deltaColumn, deltaRow, evt.shiftKey == true);\n    this.setFocusAndTextSelection(this.currentCell);\n    evt.stopPropagation();\n    evt.preventDefault();\n  }\n  \n  startEditingCurrentCell() {\n    if (!this.currentCell) return\n    // lively.showElement(this.currentCell).style.outline = \"4px dashed green\"\n    this.currentCell.contentEditable = true;\n    this.currentCell.classList.add(\"editing\");\n    this.dispatchEvent(new CustomEvent(\"start-editing-cell\"))\n    this.currentCell.focus()        \n  }\n \n  stopEditingCurrentCell() {\n    if (!this.currentCell) return\n    // lively.showElement(this.currentCell).style.outline = \"4px dashed red\"\n    this.currentCell.contentEditable = false;\n    this.currentCell.classList.remove(\"editing\");\n    this.dispatchEvent(new CustomEvent(\"finish-editing-cell\"))        \n  }\n  /*MD ## Events MD*/\n  \n  onLeftDown(evt) {\n    this.handleArrowKey(evt, -1, 0);\n  }\n\n  onRightDown(evt) {\n    this.handleArrowKey(evt, 1, 0);\n  }\n\n  onUpDown(evt) {\n    this.handleArrowKey(evt, 0, -1);\n  }\n\n  onDownDown(evt) {\n    this.handleArrowKey(evt, 0, 1);\n  }\n\n  // #important\n  onMouseDown(evt) {\n    var cell = evt.composedPath()[0];\n    if (cell === this.currentCell) {\n      if (this.isInEditing(this.currentCell)) {\n        return \n      } else {\n        // edit only on second click into selection #TODO does not work any more... edit seems to be always on\n        this.startEditingCurrentCell()      \n      }\n    } else {\n      if (this.currentCell && this.currentCell.classList.contains(\"editing\")) {\n        this.stopEditingCurrentCell()\n      }\n      \n      this.focus()\n      this.selectCell(cell);\n      this.setFocusAndTextSelection(this.currentCell);\n    }\n    evt.stopPropagation();\n    evt.preventDefault();\n\n    if (cell !== this.currentCell) {\n      this.clearSelection(true);\n      this.selectCell(cell);\n    }\n\n    lively.addEventListener(\"LivelyTable\", document.body, \"mousemove\", evt => this.onMouseMoveSelection(evt));\n    lively.addEventListener(\"LivelyTable\", document.body, \"mouseup\", evt => this.onMouseUpSelection(evt));\n    \n    evt.preventDefault()\n    evt.stopPropagation()\n  }\n\n  onMouseMoveSelection(evt) {\n    var cell = evt.composedPath()[0];\n    if (this.isCell(cell)) {\n      if (cell === this.currentCell) return;\n\n      this.clearSelection(true);\n\n      var column = this.columnOfCell(cell);\n      var row = this.rowOfCell(cell);\n\n      this.changeSelectionBetween(this.startColumnIndex, column, this.startRowIndex, row\n\n      // lively.notify(\"mouse move\")\n      );\n    }\n  }\n\n  //\n  // Mouse Events\n  //\n\n  onMouseUpSelection(evt) {\n    lively.removeEventListener(\"LivelyTable\", document.body, \"mousemove\");\n    lively.removeEventListener(\"LivelyTable\", document.body, \"mouseup\");\n\n    var cell = evt.composedPath()[0];\n    if (cell === this.currentCell) return;\n\n    this.setFocusAndTextSelection(this.currentCell\n    // var sel = window.getSelection();\n    // sel.removeAllRanges();\n    // var range = document.createRange();\n    // this.currentCell.focus()\n    // range.selectNodeContents(this.currentCell);  \n    // sel.addRange(range);\n    );\n  }\n\n  onClick(evt) {\n    \n  }\n  \n  /*MD ## Copy and Paste MD*/\n  \n  onCopy(evt) {\n    // lively.notify(\"on copy\")\n\n    if (!this.currentCell) return;\n    if (this.selectedCells && this.selectedCells.length > 1) {\n      var data = this.getSelectionAsCSV\n      // lively.notify(\"data \" + data)\n      ();evt.clipboardData.setData('text/plain', data);\n    } else {\n      var selString = window.getSelection().toString();\n      if (selString.length > 0) {\n        evt.clipboardData.setData('text/plain', selString);\n      } else {\n        evt.clipboardData.setData('text/plain', this.currentCell.textContent);\n      }\n    }\n    evt.stopPropagation();\n    evt.preventDefault();\n  }\n\n  onCut(evt) {\n    this.onCopy(evt);\n    if (this.selectedCells && this.selectedCells.length > 1) {\n      // lively.notify(\"cut \" + this.selectedCells.length)\n      this.selectedCells.forEach(ea => {\n        ea.textContent = \"\";\n      });\n    } else {\n      this.currentCell.textContent = \"\";\n    }\n  }\n\n  onPaste(evt) {\n    // lively.notify(\"on paste\")\n\n    if (!this.currentCell) return;\n\n    var cells;\n    if (this.selectedCells && this.selectedCells.length > 1) {\n      // lively.notify(\"cut \" + this.selectedCells.length)\n      cells = this.selectedCells;\n    } else {\n      cells = [this.currentCell];\n    }\n\n    var data = evt.clipboardData.getData('text/plain');\n\n    this.selectedCells.map(ea => {\n      // cells will change so get them early... \n      return { column: this.columnOfCell(ea), row: this.rowOfCell(ea) };\n    }).forEach(ea => {\n      this.setFromCSVat(data, ea.column, ea.row);\n    });\n    evt.stopPropagation();\n    evt.preventDefault();\n  }\n  \n  /*MD ## Rows and Columns MD*/\n  \n  insertColumnAt(index) {\n    this.cells().forEach(cellArray => {\n      var oldCell = cellArray[index];\n      var newCell = document.createElement(oldCell.tagName);\n      oldCell.parentElement.insertBefore(newCell, oldCell);\n      newCell.style.width = oldCell.style.width;\n    });\n  }\n\n  removeColumnAt(index) {\n    this.cells().forEach(cellArray => {\n      var oldCell = cellArray[index];\n      oldCell.remove();\n    });\n  }\n\n  isInFocus(focusedElement = lively.activeElement()) {\n    if (focusedElement === this) return true;\n    if (!focusedElement) return false;\n    return this.isInFocus(focusedElement.parentElement || focusedElement.parentNode );\n  }\n\n  insertRowAt(index) {\n    var oldRow = this.rows()[index];\n    var newRow = document.createElement(\"tr\");\n    newRow.innerHTML = oldRow.innerHTML;\n    newRow.querySelectorAll(\"th,td\").forEach(ea => ea.textContent = \"\");\n    oldRow.parentElement.insertBefore(newRow, oldRow);\n    return newRow;\n  }\n\n  removeRowAt(index) {\n    var oldRow = this.rows()[index];\n    oldRow.remove();\n  }\n\n  /*MD # Accessing Content MD*/\n  \n  asArray() {\n    return Array.from(this.querySelectorAll(\"tr\")).map(eaRow => {\n      return Array.from(eaRow.querySelectorAll(\"td,th\")).map(eaCell => eaCell.textContent);\n    });\n  }\n  \n  asCSV() {\n    return this.asArray().map(eaRow => eaRow.join(\"\\t\")).join(\"\\n\");\n  }\n\n  asJSO() {\n    var all = this.asArray();\n    var header = all[0];\n    return all.slice(1).map(row => {\n      var obj = {};\n      row.forEach((ea, index) => {\n        var name = header[index];\n        obj[name] = ea;\n      });\n      return obj;\n    });\n  }\n  \n  // #private\n  maxColumnsIn(array) {\n    return array.reduce((sum, ea) => Math.max(sum, ea.length), 0);\n  }\n\n  setFromArrayClean(array) {\n    var maxColumns = this.maxColumnsIn(array);\n    this.innerHTML = \"<table>\" + array.map((row, rowIndex) => {\n      var html = \"\";\n      for (var i = 0; i < maxColumns; i++) {\n        var ea = row[i] !== undefined ? row[i] : \"\";\n        html += rowIndex == 0 ? // header \n        `<th style=\"width: 40px\">${ea}</th>` : `<td>${ea}</th>`;\n      }\n      return \"<tr>\" + html + \"</tr>\";\n    }).join(\"\\n\") + \"</table>\";\n    this.registerOnAllCells();\n  }\n\n  setFromArray(array, force) {\n    if (!this.querySelector(\"tbody\") || force) {\n      this.setFromArrayClean(array);\n    } else {\n      var maxColumns = this.maxColumnsIn(array);\n      this.rows().filter((ea, index) => index >= array.length).forEach(ea => ea.remove());\n      this.cells().forEach(row => {\n        row.filter((cell, index) => {\n          return index >= maxColumns;\n        }).forEach(ea => ea.remove());\n      });\n      this.querySelectorAll(\"td,th\").forEach(ea => ea.textContent = \"\");\n      this.setFromArrayAt(array, 0, 0);\n    }\n  }\n\n  setFromArrayAt(array, columnOffset, rowOffset) {\n    var cells = this.cells();\n    var header = cells[0];\n    var tableLength = columnOffset + array[0].length;\n    // lively.notify(\"grow table? \" + tableLength  + \" \" + header.length + \" | \" + columnOffset + \" \" + array.length )\n    if (tableLength > header.length) {\n      var rows = this.rows\n      // we have to grow wider\n      ();rows.forEach((row, index) => {\n        for (var i = 0; i < tableLength - header.length; i++) {\n          var cell = document.createElement(\"td\");\n          row.appendChild(cell);\n        }\n      }\n      // we changed this contents and have to update\n      );cells = this.cells();\n      header = cells[0];\n    }\n    for (var i = 0; i < array.length; i++) {\n      var row = cells[rowOffset + i];\n      if (!row) {\n        var rowElement = document.createElement(\"tr\");\n        rowElement.innerHTML = header.map(ea => \"<td></td>\").join(\"\");\n        this.querySelector(\"tbody\").appendChild(rowElement);\n        var row = rowElement.querySelectorAll(\"td\");\n        cells.push(row);\n      }\n      var fromRow = array[i];\n      for (var j = 0; j < fromRow.length; j++) {\n        var index = columnOffset + j;\n        var cell = row[index];\n        if (!cell) throw new Error(\"No cell at \" + index + \", in \" + row);\n        cell.textContent = fromRow[j];\n      }\n    }\n    this.registerOnAllCells();\n  }\n\n  \n  // #private\n  splitIntoRows(csv, separator = /[;\\t,]/) {\n    return csv.split(\"\\n\").map(line => {\n      return line.split(separator).map(ea => {\n        var m = ea.match(/^\"(.*)\"$/);\n        if (m) {\n          return m[1];\n        } else {\n          return ea;\n        }\n      });\n    });\n  }\n\n  setFromCSV(csv, separator) {\n    this.setFromArray(this.splitIntoRows(csv, separator));\n  }\n  \n  setFromCSVat(csv, column, row, separator) {\n    this.setFromArrayAt(this.splitIntoRows(csv, separator), column, row);\n  }\n  \n  /*\n   * set the contents of the table from a JSO where the keys of each object will become the header\n   * example: [{a: 1, b: 2}, {a: 4, b: 5, c: 6}]\n   */\n  setFromJSO(jso, clean=false) {\n    if (!jso) return;\n    var headers = [];\n    var rows = jso.map(obj => {\n      obj = obj || {};\n      // add headers that are introduced in that row\n      Object.keys(obj).forEach(key => {\n        if (headers.indexOf(key) < 0) {\n          headers.push(key);\n        }\n      });\n      return headers.map(key => {\n        return obj[key];\n      });\n    });\n    rows.unshift(headers);\n    if (clean) {\n      this.setFromArrayClean(rows);\n    } else {\n      this.setFromArray(rows); // #TODO why do we need this optimization again?\n    }\n  }\n\n\n  // #private\n  copySelectionAsTable() {\n    var tmp = LivelyTable.create();\n    tmp.setFromArray(_.values(_.groupBy(this.selectedCells, ea => this.rowOfCell(ea))).map(row => _.sortBy(row, ea => this.columnOfCell(ea)).map(ea => ea.textContent)));\n    return tmp;\n  }\n\n  getSelectionAsCSV() {\n    return this.copySelectionAsTable().asCSV();\n  }\n\n  getSelectionAsJSO() {\n    if (!this.selectedCells) return [];\n\n    let result = [];\n\n    this.selectedCells.forEach(each => {\n      let row = this.rowOfCell(each);\n      let key = this.keyForCell(each);\n      if (!result[row]) result[row] = {};\n      result[row][key] = each.textContent;\n    });\n\n    return result;\n  }\n\n\n\n  \n  \n  \n  /*MD ## Lively4 API MD*/\n\n  livelyMigrate(other) {\n    this.clearSelection();\n    var selection = this.cellAt(other.currenColumnIndex, other.currentRowIndex);\n    if (selection) this.selectCell(selection);\n  }\n\n  // #important #lively4api\n  livelyExample() {\n    this.setFromArray([['A', 'B', 'C', 'D', 'E'], ['First', 'Second', 'Third', 'Fourth', ''], ['Hello', 'World', '', '', ''], ['Foo', 'Bar', '', '', '']]);\n  }\n    \n  /*MD ## Excel Functionality MD*/\n  getCellValue(column, row) {\n    const cell = this.cellFromCode(column, row);\n    if(!cell) return undefined;\n    const expression = this.activeExpression[(row - 1) + \"_\" + this.columnIndex(column)];\n    if(expression) {\n      return expression.expression.getCurrentValue();\n    }\n    let val = cell.textContent;\n    if(this.currentCell === cell) {\n      val = this.currentCellValue;\n    }\n    return isNaN(+val) ? val : +val;\n  }\n  \n  \n  registerOnAllCells() {\n    const cells = this.cells();\n    for(let r = 0; r < cells.length; r++) {\n      const row = cells[r];\n      for(let c = 0; c < row.length; c++) {\n        const cell = row[c];\n        aexpr(() => cell === this.currentCell).onChange((isActive) => this.cellChangedActive(cell, isActive, c, r));\n      } \n    }\n  }\n  \n  cellChangedActive(cell, isActive, column, row) {\n    const text = cell.textContent;\n    if(isActive) {\n      const expression = this.activeExpression[row + \"_\" + column];\n      if(expression) {\n        this.currentCellValue = expression.expression.getCurrentValue();\n        expression.expression.dispose();\n        cell.textContent = expression.text;\n      } else {        \n        this.currentCellValue = cell.textContent;\n      }\n      delete this.activeExpression[row + \"_\" + column];\n    } else {\n      if(text[0] === '=') {\n        debugger;\n        cell.setAttribute(\"bgcolor\", \"CCFFCC\");\n        let code = text.substring(1, text.length);\n        const [expressionCode, onChangeCode] = code.split('|'); \n        const expression = aexpr(() => this.evaluateCellText(expressionCode)).dataflow((newValue) => cell.textContent = newValue);\n        if(onChangeCode) {\n          expression.dataflow((value) => {eval(onChangeCode)});\n        }\n        this.activeExpression[row + \"_\" + column] = {expression, text};\n      } else {        \n        cell.removeAttribute(\"bgcolor\");\n      }\n    }\n  }\n  \n  evaluateCellText(code) {\n    let params = {};\n    return eval(code.replace(/\\$([a-zA-Z]+)(\\d+)/gm, (ref, column, row) => {\n      params[ref] = this.getCellValue(column, row);\n      return \"params[\\\"\" + ref + \"\\\"]\";\n    }));\n  }\n  \n  \n  /** \n    @param column: The column in A - ZZ... Format\n    @param rowIndex: The Index of the row in 1 - Infintiy Range\n    @Return the corresponding cell\n   */\n  cellFromCode(column, rowIndex) {\n    return this.cellAt(this.columnIndex(column), rowIndex - 1)\n  }\n  \n  columnIndex(column) {\n    var a = column.toUpperCase();\n    let columnIndex = 0;\n    while(a.length > 0) {\n      columnIndex *= 26;\n      columnIndex += a.charCodeAt(a.length - 1) - 65;\n      a = a.substring(0, a.length - 1);\n    }\n    return columnIndex;\n  }\n}"}