{"type":"Reference","version":"0b588340f54840b826b71de139626b3d1d945646","content":"\"enable aexpr\";\n\nimport Morph from 'src/components/widgets/lively-morph.js';\nimport _ from 'src/external/lodash/lodash.js';\n\nconst DEFAULT_SNIPPET = '// Enter simulation code here';\nconst HIGHLIGHT_BG_COLOR = 'cornflowerblue';\n\nexport default class LivelySimulationCode extends Morph {\n    \n  // lifecycle\n  initialize() {\n    this.initializeCodeMirror();\n    this.initializeSaveDiscard();\n  }\n  \n  initializeCodeMirror() {\n    const codeMirror = this.get('#codeMirror');\n    codeMirror.addEventListener('focusout', () => this.handleFocusOut());\n    codeMirror.addEventListener('focusin', () => this.handleFocusIn());\n    codeMirror.checkSyntax = () => {};\n    codeMirror.setCustomStyle('.CodeMirror * { font-size: 0.7rem } .cm-error { color: inherit !important; }');\n  }\n  \n  initializeSnippet(snippet = DEFAULT_SNIPPET) {\n    const codeMirror = this.get('#codeMirror');\n    codeMirror.editView(snippet);\n    codeMirror.editorLoaded().then(() => this.initializeEditor());\n  }\n  \n  initializeEditor() {\n    const codeMirror = this.get('#codeMirror');\n    codeMirror.editor.setOption('lineNumbers', false);\n    codeMirror.editor.setOption('gutters', []);\n    codeMirror.editor.setOption('highlight', false);\n    codeMirror.editor.setOption('lint', false);\n    codeMirror.editor.refresh();\n    this.preCompile();\n    this.updateCellTags();\n  }\n  \n  initializeSaveDiscard() {\n    const save = this.get('#save');\n    save.addEventListener('click', () => this.handleSaveDiscard(true));\n    const discard = this.get('#discard');\n    discard.addEventListener('click', () => this.handleSaveDiscard(false));\n  }\n  \n  attachedCallback() {\n    this.registerCellName();\n  }\n  \n  detachedCallback() {\n    this.cellNameUpdater.dispose();\n  }\n  \n  registerCellName() {\n    this.cellNameUpdater = aexpr(() => {\n      const codeView = this.getCodeView();\n      return codeView.getCell().getNormalizedName();\n    }).dataflow((cellName) => {\n      if (!_.isEmpty(cellName)) this.preCompile();\n    });\n  }\n  \n  // event handler\n  handleFocusOut() {\n    if (this.checkpoint === this.getSnippet()) this.handleSaveDiscard(false);\n  }\n  \n  handleFocusIn() {\n    if (!this.isEditing) {\n      this.isEditing = true;\n      this.checkpoint = this.getSnippet();\n      const saveDiscard = this.get('#saveDiscard');\n      saveDiscard.classList.add('show');\n    }\n    this.clearAllMarks();\n  }\n  \n  handleCellRef(event, cellRef) {\n    if (this.hasFocus) return;\n    const simulation = this.getSimulation();\n    if (simulation && simulation.toggleHighlight)\n      simulation.toggleHighlight(cellRef);\n    event.preventDefault();\n  }\n  \n  handleSaveDiscard(save) {\n    const saveDiscard = this.get('#saveDiscard');\n    saveDiscard.classList.remove('show');\n    this.isEditing = false;\n    if (save) this.save();\n    else this.discard();\n    this.updateCellTags();\n  }\n  \n  // other\n  save() {\n    this.preCompile();\n  }\n  \n  discard() {\n    this.setSnippet(this.checkpoint);\n  }\n  \n  execute(state) {\n    const cellNames = _.keys(state);\n    try {\n      this.precompiled.apply(state);\n      this.clearError();\n    } catch ({ message }) {\n      this.setError(message);\n    }\n    return Promise.resolve(_.pick(state, cellNames));\n  }\n  \n  preCompile() {\n    try {\n      const snippet = this.getSnippet();\n      const preProcessedSnippet = this.preProcess(snippet);\n      this.precompiled = new Function(preProcessedSnippet);\n      this.clearError();\n    } catch ({ message }) {\n      this.setError(message);\n    }\n  }\n  \n  preProcess(snippet) {\n    const codeView = this.getCodeView();\n    if (!codeView) return;\n    const localState = codeView.getState();\n    const name = codeView.getCell().getNormalizedName();\n    let processedSnippet = snippet;\n    processedSnippet = this.preImportStateAsLocal(processedSnippet, name, localState);\n    processedSnippet = this.preImportSimulationAsLocal(processedSnippet, localState);\n    processedSnippet = this.preTransformExternalState(processedSnippet);\n    processedSnippet = this.preExportStateAsLocal(processedSnippet, name, localState);\n    return processedSnippet;\n  }\n  \n  preTransformExternalState(processedSnippet) {\n    // adapted from old simulation (#Cell -> this['cell'])\n    return processedSnippet.replace(/#([A-Za-z][A-Za-z0-9]*(?:#[A-Za-z0-9]*)*)(\\$)?(?!#)/g, \n        (m, $1) => {\n            var s = \"this\"\n            $1.split(\"#\").forEach(function(ea) { s += \"['\" + ea.charAt(0).toLowerCase() + ea.slice(1) +\"']\"})\n            return s\n        })\n  }\n  \n  preImportStateAsLocal(snippet, name, localState) {\n    if (_.isEmpty(localState)) return snippet;\n    return `let { ${name}: { ${_.join(_.keys(localState), ',')} } } = this;\\n\n            ${snippet}`;\n  }\n  \n  preImportSimulationAsLocal(snippet, localState) {\n    if (_.isEmpty(localState)) return snippet;\n    return `const { simulation: { dt, time } } = this;\\n${snippet}`;\n  }\n  \n  preExportStateAsLocal(snippet, name, localState) {\n    if (_.isEmpty(localState)) return snippet;\n    return `${snippet}\\n\n            this['${name}'] = {\n              ${ _.join(_.keys(localState), ',\\n') }\n            };`;\n  }\n  \n  updateCellTags() {\n    this.clearAllMarks();\n    const snippet = this.getSnippet();\n    const re = /#([A-Za-z][A-Za-z0-9]*(?:#[A-Za-z0-9]*)*)(\\$)?(?!#)/g;\n    let match;\n    while ((match = re.exec(snippet)) != null) {\n      this.addWidget(match);\n    }    \n    const simulation = this.getSimulation();\n    if (!simulation) return;\n    this.highlight(simulation.currentHighlight);\n  }\n  \n  addWidget(match) {\n    const cm =  this.get('#codeMirror').editor;\n    const cellRef = match[1].toLowerCase();\n    const widget = <span style='cursor: pointer; transition: background-color 0.3s ease; text-decoration: underline;'>{ match[0] }</span>;\n    widget.dataset['cellref'] = cellRef;\n    widget.addEventListener('mousedown', (event) => this.handleCellRef(event, cellRef));\n    try {\n      cm.markText(\n        cm.posFromIndex(match.index),\n        cm.posFromIndex(match.index + match[0].length), \n        { replacedWith: widget }\n      );\n    } catch (error) { /* ignore */ }\n  }\n  \n  clearAllMarks() {\n    const cm =  this.get('#codeMirror').editor;\n    _.forEach(cm.getAllMarks(), mark => mark.clear());\n  }\n  \n  highlight(cellRef) {\n    this.clearConnector();\n    if (!cellRef) {\n      this.clearMarkupHighlight();\n    } else {\n      const matchingWidgets = this.updateMarkupHighlights(cellRef);\n      if (!_.isEmpty(matchingWidgets)) this.createConnector(cellRef);\n    }\n  }\n  \n  clearConnector() {\n    if (this.connector) {\n      this.connector.remove();\n      this.connector = undefined;\n    }\n  }\n  \n  updateMarkupHighlights(cellRef) {\n    const cm =  this.get('#codeMirror').editor;\n    const widgets = _.map(cm.getAllMarks(), mark => _.get(mark, 'widgetNode.children[0]'));\n    const matchingWidgets = _.filter(widgets, widget => widget.dataset['cellref']== cellRef);\n    const otherWidgets = _.reject(widgets, widget => widget.dataset['cellref']== cellRef);\n    _.forEach(otherWidgets, widget => widget.style.backgroundColor = '');\n    _.forEach(matchingWidgets, widget => widget.style.backgroundColor = HIGHLIGHT_BG_COLOR);\n    return matchingWidgets;\n  }\n  \n  clearMarkupHighlight() {\n    const cm =  this.get('#codeMirror').editor;\n    const widgets = _.map(cm.getAllMarks(), mark => _.get(mark, 'widgetNode.children[0]'));\n    _.forEach(widgets, widget => widget.style.backgroundColor = '');\n  }\n  \n  createConnector(cellRef) {\n    this.clearConnector();\n    const targetCell = _.find(this.getSimulation().collectCells(), cell => cell.getNormalizedName().toLowerCase() === cellRef);\n    if (targetCell) {\n      Promise.resolve(<lively-connector></lively-connector>)\n        .then(connector => {\n          this.initializeConnector(connector, targetCell);\n          this.connector = connector;\n        });\n    }\n  }\n  \n  initializeConnector(connector, targetCell) {\n    this.getSimulation().appendChild(connector);\n    connector.connectFrom(this.getCodeView().getCell(), false, true);\n    connector.connectTo(targetCell, false, true);\n    connector.style.zIndex = 9999;\n    connector.style.cursor = 'pointer';\n    connector.addEventListener('click', () => targetCell.scrollIntoView());\n  }\n  \n  setSnippet(snippet) {\n    const codeMirror = this.get('#codeMirror');\n    codeMirror.editor.setValue(snippet);\n    this.preCompile(snippet);\n  }\n  \n  get(selector) {\n    const { shadowRoot } = this;\n    return shadowRoot.querySelector(selector);\n  }\n  \n  setError(error) {\n    const status = this.get('#status');\n    status.innerText = error;\n    status.classList.add('error');\n  }\n  \n  clearError() {\n    const status = this.get('#status');\n    status.innerText = '';\n    status.classList.remove('error');\n  }\n  \n  getSnippet() {\n    const editor = this.get('#codeMirror').editor;\n    return editor ? editor.getValue() : '';\n  }\n  \n  isFocused() {\n    return this.isChildFocused(this.get('#codeMirror'));\n  }\n  \n  isChildFocused(child, doc = document) {\n    if (doc.activeElement === child) return true;\n    if (doc.activeElement && doc.activeElement.shadowRoot)\n\t\t\treturn this.isChildFocused(child, doc.activeElement.shadowRoot)\n    return false;\n  }\n  \n  getCodeView() {\n    return this.getRootNode().host;\n  }\n  \n  getSimulation() {\n    const codeView = this.getCodeView();\n    if (!codeView) return;\n    const cell = codeView.getCell();\n    if (!cell) return;\n    return cell.getSimulation();  \n  }\n}"}