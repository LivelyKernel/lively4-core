{"type":"Reference","version":"1d05ffaae74e8fcdac17f3f517a9cd1647d5d48f","content":"\nimport sourcemap from 'src/external/source-map.min.js';\n\n/*MD # Stack MD*/\nexport default class Stack {\n  static get defaultErrorMessage() {\n    return 'Error for stack';\n  }\n  constructor({ omitFn = Stack, max }) {\n    Error.stackTraceLimit = Infinity;\n    Error.captureStackTrace(this._error = {}, omitFn);\n    this._frames = this._computeFrames(this._error.stack, max);\n  }\n  _computeFrames(desc, max) {\n    return desc.lines().slice(1, max).map(line => new Frame(line));\n  }\n  get frames() {\n    return this._frames;\n  }\n  getFrame(id = 1) {\n    return this.frames[id];\n  }\n  getFrames(from, to) {\n    return this.frames.slice(from, to);\n  }\n  toString() {\n    return this.frames.join('\\n');\n  }\n}\n\n/*MD # Frame\nView some examples at [regex101](https://regex101.com/r/pSppPm/3)\nMD*/\nexport class Frame {\n  constructor(desc) {\n    this._desc = desc;\n    this._extractInfos(this._desc);\n  }\n\n  _extractInfos(desc) {\n    // just file, transpiled, line, char given -> no parens around\n    // \" at https://lively-kernel.org/lively4/aexpr/src/external/mocha.js?1583757762700:4694:7\"\n    if (!this._desc.endsWith(')')) {\n      const extractSourceInfo = /^\\s+at\\s(.*)$/;\n      const result = extractSourceInfo.exec(desc);\n      // lively.openInspector(result)\n      const info = this._getFileLineChar(result[1]);\n      this._applyLocationInfo(info);\n\n      return;\n    }\n\n    // e.g. \" at Function.stack (https://lively-kernel.org/lively4/aexpr/src/client/lively.js!transpiled:2548:19)\"\n    const isNamedCall = /^\\s+at\\s([^\\(]*)\\s\\((.*)\\)$/;\n    let namedCall;\n    if ((namedCall = isNamedCall.exec(desc)) !== null) {\n      const [, funcDesc, location] = namedCall;\n\n      let locations;\n      // \" at doEvaluate (eval at loadJavaScript (https://lively-kernel.org/lively4/aexpr/src/client/boot.js:25:3), &lt;anonymous>:1554:13)\"\n      // can also have no infos on function name of eval call:\n      // \"    at eval (eval at <anonymous> (https://lively-kernel.org/lively4/aexpr/test/stack-test.js!transpiled), <anonymous>:8:19)\"\n      const getLocations = /^(?:eval\\sat\\s(.*\\)),\\s)?(.*)$/;\n      if ((locations = getLocations.exec(location)) !== null) {\n        const [, evalInfo, sourceLocation] = locations;\n\n        if (evalInfo) {\n          this._extractEvalInfos(evalInfo);\n        }\n\n        const info = this._getFileLineChar(sourceLocation);\n        this._applyLocationInfo(info);\n      }\n\n      const info2 = this._getFunction(funcDesc);\n      this._applyFunctionInfo(info2);\n\n      return;\n    }\n\n    lively.warn('could not analyse frame', desc);\n  }\n\n  _extractEvalInfos(desc) {\n    const isNamedCall = /^([^\\(]*)\\s\\((.*)\\)$/;\n    let namedCall;\n    if ((namedCall = isNamedCall.exec(desc)) !== null) {\n      const [, funcDesc, location] = namedCall;\n\n      const info = this._getFileLineChar(location);\n      this._applyEvalLocationInfo(info);\n\n      const info2 = this._getFunction(funcDesc);\n      this._applyEvalFunctionInfo(info2);\n    }\n  }\n\n  /*MD ## location utils MD*/\n  _getFileLineChar(locationDesc) {\n    function reverseString(str) {\n      return str.split('').reverse().join('');\n    }\n\n    const reversedDesc = reverseString(locationDesc);\n    const reversedFileLineChar = /^(?:(\\d+):)?(?:(\\d+):)?(?:(delipsnart)!)?(.*)$/;\n\n    const [, char, line, transpiled, file] = reversedFileLineChar.exec(reversedDesc);\n\n    return {\n      char: char && parseInt(reverseString(char)),\n      line: line && parseInt(reverseString(line)),\n      transpiled: !!transpiled,\n      file: reverseString(file)\n    };\n  }\n\n  _applyLocationInfo({ char, line, transpiled, file }) {\n    this._char = char;\n    this._line = line;\n    this._transpiled = transpiled;\n    this._file = file;\n  }\n\n  _applyEvalLocationInfo({ char, line, transpiled, file }) {\n    this._evalChar = char;\n    this._evalLine = line;\n    this._evalTranspiled = transpiled;\n    this._evalFile = file;\n  }\n\n  /*MD ## func utils MD*/\n  _getFunction(desc) {\n    const newAsyncFunc = /^(?:(new)\\s)?(?:(async)\\s)?(.+)$/;\n\n    const [, isNew, isAsync, func] = newAsyncFunc.exec(desc);\n\n    return {\n      isNew: !!isNew,\n      isAsync: !!isAsync,\n      func\n    };\n  }\n\n  _applyFunctionInfo({ isNew, isAsync, func }) {\n    this._new = isNew;\n    this._async = isAsync;\n    this._func = func;\n  }\n\n  _applyEvalFunctionInfo({ isNew, isAsync, func }) {\n    this._evalNew = isNew;\n    this._evalAsync = isAsync;\n    this._evalFunc = func;\n  }\n\n  async _determineSourceInfo() {\n    if(this._file === \"<anonymous>\") return;\n    const [livelyPath, srcPath] = this._file.split(\"/src/\");\n    if(!this._transpiled || !srcPath) {\n      this._sourceLoc = {line: this._line, column: this._char, source: this._file};\n      return;\n    }\n    const sourceMappingURL = livelyPath + \"/.transpiled/\" + (\"src/\" + srcPath).replaceAll(\"/\", \"_\") + \".map.json\";\n    var sourceMap = await sourceMappingURL.fetchJSON();\n    var smc = sourcemap.SourceMapConsumer(sourceMap);\n    this._sourceLoc = smc.originalPositionFor({\n      line: parseInt(this._line),\n      column: parseInt(this._char)\n    });\n  }\n  \n  /*MD ## func MD*/\n  /**\n   * returns Bool\n   */\n  get async() {\n    return this._async || false;\n  }\n\n  get new() {\n    return this._new || false;\n  }\n\n  get func() {\n    return this._func;\n  }\n\n  /*MD ## location MD*/\n  get file() {\n    return this._file;\n  }\n\n  get transpiled() {\n    return this._transpiled || false;\n  }\n\n  get line() {\n    return this._line;\n  }\n\n  get char() {\n    return this._char;\n  }\n  \n  async getSourceLocBabelStyle() {\n    if(!this._sourceLoc) {\n      await this._determineSourceInfo();\n    }\n    const location = {line: this._sourceLoc.line, column: this._sourceLoc.column};\n    return {start: location, end: location, file: this._sourceLoc.source};\n  }\n  \n  async getSourceLoc() {\n    if(!this._sourceLoc) {\n      await this._determineSourceInfo();\n    }\n    return this._sourceLoc;\n  }\n  \n  async getSourceLine() {\n    if(!this._sourceLoc.line) {\n      await this._determineSourceInfo();\n    }\n    return this._sourceLoc.line;\n  }\n  \n  async getSourceChar() {\n    if(!this._sourceLoc.character) {\n      await this._determineSourceInfo();\n    }\n    return this._sourceLoc.column;\n  }\n\n  /*MD ## eval func MD*/\n  /**\n   * returns Bool\n   */\n  get evalAsync() {\n    return this._evalAsync || false;\n  }\n\n  get evalNew() {\n    return this._evalNew || false;\n  }\n\n  get evalFunc() {\n    return this._evalFunc;\n  }\n\n  /*MD ## eval location MD*/\n  get evalFile() {\n    return this._evalFile;\n  }\n\n  get evalTranspiled() {\n    return this._evalTranspiled;\n  }\n\n  get evalLine() {\n    return this._evalLine;\n  }\n\n  get evalChar() {\n    return this._evalChar;\n  }\n\n  /*MD ## utils MD*/\n  // #TODO: implement\n  openInBrowser(browser) {\n    // #TODO: requires back mapping of source code information #SourceMaps\n  }\n\n  toString() {\n    return this._desc.replace(/\\s+at\\s/, '');\n  }\n\n}"}