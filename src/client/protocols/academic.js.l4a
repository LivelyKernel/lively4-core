{"type":"Reference","version":"f52280b7204e9d796b626accf26c0bf12e41873d","content":"import { Scheme } from \"src/client/poid.js\";\nimport PolymorphicIdentifier from \"src/client/poid.js\";\nimport focalStorage from \"src/external/focalStorage.js\";\nimport { parseQuery, getDeepProperty } from 'utils';\n\nimport BibtexParser from 'src/external/bibtexParse.js';\nimport Bibliography from \"src/client/bibliography.js\"\n\nimport FileIndex from \"src/client/fileindex.js\";\n\nimport Literature from \"src/client/literature.js\"\n\nimport _ from 'src/external/lodash/lodash.js';\n/*MD \n# Microsoft Academic Search \nMD*/\n\n/*MD \n<style>* {background-color:lightgray}</style>\n\n### Documentation\n\n<https://docs.microsoft.com/en-us/academic-services/project-academic-knowledge/reference-paper-entity-attributes>\n\n### Microsoft Academic Raw Query:\n\n```javascript{.example}\n  fetch(\"https://academic.microsoft.com/api/search\", {\n        method: \"POST\",\n        headers: {\n          \"content-type\": \"application/json; charset=utf-8\"\n        },\n        body: JSON.stringify({\n          query: \"\", \n          queryExpression: \"Composite(AA.AuN='jens lincke')\", \n          filters: [], \n          orderBy: 0, \n          skip: 0,\n          sortAscending: true, \n          take: 10})\n        }).then(r => r.json())\n```\n\n\n### And with our Scheme\n\n```javascript\nfetch(\"academic://Jens Lincke 2009\", {\n  method: \"GET\",\n  headers: {\n    \"content-type\": \"application/json\"\n  }\n}).then(r => r.json())\n```\n\nWe also support different content type, e.g. the default is HTML\n\n```javascript\nfetch(\"academic://Jens Lincke 2009\", {\n  method: \"GET\",\n  headers: {\n    \"content-type\": \"text/html\"\n  }\n}).then(r => r.text())\n```\n\nor bibtex\n\n```javascript\nfetch(\"academic://Jens Lincke 2009\", {\n  method: \"GET\",\n  headers: {\n    \"content-type\": \"application/bibtex\"\n  }\n}).then(r => r.text()).then(s => {\n  return s\n} )\n```\n\n\nMD*/\n\nimport MarkdownIt from \"src/external/markdown-it.js\";\n\nexport class MicrosoftAcademicEntities {\n\n  \n  static get baseURL() {\n    return \"https://raw.githubusercontent.com/MicrosoftDocs/microsoft-academic-services/live/academic-services/project-academic-knowledge/\";\n  }\n\n  static async generateSchema(entityName) {\n    return this.schemaFromURL(this.baseURL + \"reference-\" + entityName + \"-entity-attributes.md\")\n  }\n    \n  \n  static async schemaFromURL(url) {\n    var content = await fetch(url).then(r => r.text());\n    var md = new MarkdownIt();\n    var html = md.render(content);\n    var div = <div></div>;\n    div.innerHTML = html;\n    var tbody = div.querySelector(\"tbody\");\n    return tbody ? Array.from(tbody.querySelectorAll(\"tr\").map(ea => Array.from(ea.querySelectorAll(\"td\").map(td => td.textContent))).map(ea => ({ name: ea[0], description: ea[1], type: ea[2], operations: ea[3] }))) : [];\n  }  \n\n  static entityTypeEnum() {\n    return [\"paper\", \"author\", \"journal\", \"conference-series\", \"conference-instance\", \"affiliation\", \"field-of-study\"]\n  }\n    \n  static getEntityType(i) {\n    return this.entityTypeEnum()[i]\n  }\n    \n  static async allSchemas() {\n    var all = {};\n    all.entity =  await this.schemaFromURL(this.baseURL + \"reference-entity-attributes.md\")\n    \n    //all.entityTypeEnum = [\"Paper\", \"Author\", \"Journal\", \"Conference Series\", \"Conference Instance\", \"Affiliation\", \"Field Of Study\"]\n    all.entityTypeEnum = this.entityTypeEnum()\n\n    for (var ea of [\"affiliation\", \"author\", \"conference-instance\", \"conference-series\", \"field-of-study\", \"journal\", \"paper\"]) {\n      var list = await this.generateSchema(ea);\n      var obj = {};\n      for (var item of list) {\n        obj[item.name] = item;\n      }\n\n      all[ea] = obj;\n    }\n    return all;\n  }\n\n    \n  static async schemas() {\n    // window.lively4academicSchemas = null\n    if (!window.lively4academicSchemas) {\n      window.lively4academicSchemas = await this.allSchemas();\n    }\n    return window.lively4academicSchemas;\n  }\n\n}\n\nconst academicSubscriptionKeyId = \"microsoft-academic-key\";\n\nfunction specialInspect(target, contentNode, inspector, normal) {\n    inspector.renderObjectdProperties(contentNode, target)\n    \n\n    for(var name of Object.keys(Object.getOwnPropertyDescriptors(target.__proto__))) {\n      var desc = Object.getOwnPropertyDescriptor(target.__proto__, name)\n      if (desc.get) {\n        try {\n          contentNode.appendChild(inspector.display(target[name], false, name, target))\n        } catch(e) {\n          // ignore e\n        }\n      }\n    }    \n  }\n\n\nexport class Author {\n \n  constructor(value) {\n    this.value = value\n  }\n\n  get name() {\n   return this.value.DAuN // \"Original author name\"\n  }\n  \n  get id() {\n    return this.value.AuId \n  }\n  \n  livelyInspect(contentNode, inspector, normal) {\n    specialInspect(this, contentNode, inspector, normal)\n  }\n}\n\n\nexport class Paper {\n  \n  static async ensure(raw) {\n    var existing = await Literature.getPaperEntry(raw.microsoftid)\n    if (!existing) {\n      var p = new Paper(raw)\n      if(!raw.Id) {\n        throw new Error(\"Id is missing (microsoftid)\")\n      }\n\n      Paper.setById(raw.Id, p)      \n    } else {\n      p = new Paper(existing.value)\n    }    \n    return p\n  }\n  \n  static byId(id) {\n    if (!this._byId) return\n    var paper = this._byId.get(id)\n    return paper     \n  }\n\n  static setById(id, paper) {\n    if (!this._byId) this._byId = new Map()\n    this._byId.set(id, paper)\n    Literature.addPaper(paper)\n  }\n\n  static async getId(id, optionalEntity) {\n    var paper = this.byId(id)\n    if (paper) return paper\n    if (optionalEntity) {\n      paper = await Paper.ensure(optionalEntity)    \n    } else {\n      var entry = await Literature.getPaperEntry(id)\n      if (entry) {\n        paper = new Paper(entry.value)\n      } else {\n        // download it individually\n        var resp = await fetch(\"academic://expr:Id=\" + id, {\n            method: \"GET\", \n            headers: {\n              \"content-type\": \"application/json\"}})\n        if (resp.status != 200) {\n          return // should we note it down that we did not found it?\n        }\n        var json = await resp.json()\n        paper = await Paper.ensure(json) // json.entity ?    \n      }\n    }\n    return paper\n  }\n\n  static async allBibtexEntries() {\n    return FileIndex.current().db.bibliography.toArray()\n  }\n  \n  static async importBibtexId(id) {\n    var paper = Paper.byId(id)\n    if (paper) {\n      var source = paper.toBibtex()\n      \n      var importURL = (await this.allBibtexEntries())\n            .map(ea => ea.url)\n            .find(ea => ea && ea.match(/_incomming\\.bib$/))\n      if (!importURL) {\n        lively.notify(\"no _incomming.bib found\")\n      } else {\n        var libcontent = await lively.files.loadFile(importURL)\n        \n        await lively.files.saveFile(importURL, libcontent + \"\\n\" + source )\n        lively.notify(\"PATER imported\", \"\", undefined, () => lively.openBrowser(importURL))\n      }\n    } else {\n      lively.notify(\"ERROR not paper with id '${this.microsoftid}' found\")\n    }\n  }\n  \n  \n  constructor(value) {\n    if (!value) throw new Error(\"value is missing\")\n    this.value = value\n  }\n  \n  get authors() {\n    return (this.value.AA || []).map(ea => new Author(ea)) \n  }\n\n  get authorNames() {\n    return (this.value.AA || []).map(ea => ea.DAuN) \n  }\n\n  \n  get year() {\n    return this.value.Y \n  }\n\n  get title() {\n    return (this.value.DN || \"\")// \"Original paper title\"\n      .replace(/[\"{}]/g,\"\")  // some cleanup\n  }\n\n  get doi() {\n    return this.value.DOI \n  }\n  \n  get microsoftid() {\n    return this.value.Id \n  }\n  \n  get bibtexType() {\n    return ({\n      'a': \"article\", \n      'b': \"book\", \n      'c': \"incollection\", \n      'p': \"inproceedings\"})[this.value.BT]  \n  }\n  \n  get booktitle() {\n    return this.value.BV\n  }\n  \n  get key() {\n    return this.toBibtexEntry().citationKey \n  }\n  \n  get keywords() {\n    return (this.value.F || []).map(ea => ea.DFN)    \n  }\n  \n  \n  async findBibtexFileEntries() {\n    var key = this.key\n    var entries = await Paper.allBibtexEntries()\n        \n    return entries.filter(ea => ea.key == key)    \n  }\n   \n  toBibtexEntry() {\n    var entry = {\n      entryTags: {\n        author: this.authors.map(author => author.name).join(\" and \"), \n        title: this.title,\n        year: this.year,\n        microsoftid: this.microsoftid,\n      },\n      entryType: this.bibtexType\n    }\n    if (this.booktitle) { entry.entryTags.booktitle = this.booktitle }\n    if (this.doi) { entry.entryTags.doi = this.doi }\n\n    if (this.references) {\n        entry.entryTags.microsoftreferences = this.references.map(ea => ea.microsoftid).join(\",\")\n    }\n    if (this.referencedBy) {\n        entry.entryTags.microsoftreferencedby = this.referencedBy.map(ea => ea.microsoftid).join(\",\")\n    }\n\n    entry.citationKey = Bibliography.generateCitationKey(entry)\n    return entry\n  }\n  \n  get abstract() {\n    var index = this.value.IA && this.value.IA.InvertedIndex\n    if (!index) return\n    var result = []\n    for(var word of Object.keys(index)) {\n      for (var pos of index[word]) {\n        result[pos] = word\n      }\n    }\n    return result.join(\" \")\n  }\n\n  \n  allReferencesRequery(references) {\n    if (!references || references.length == 0) return \n    return `Or(${ references.map(ea => 'Id=' + ea).join(\",\")})`\n  } \n  \n  \n  async academicQueryToPapers(query) {\n    if (!query) return []\n    try {\n      var response = await new AcademicScheme().rawQueryExpr(query, 1000)\n    } catch(e) {\n      console.warn(\"[academic] Error academicQueryToPapers \" + query + \"... BUT WE CONTINUE ANYWAY\")\n      return null\n    }\n    var result = []\n    for(var entity of response.entities) {\n      result.push(await Paper.getId(entity.Id, entity))\n    }\n    return result\n  }\n\n  async resolveMicrosoftIdsToPapers(references) {\n    var papers = []\n    var rest = []\n    \n    // bulk queries are faster\n    var entries = await Literature.getPaperEntries(references)\n    for(var microsoftid of references) {\n      // look each up if in db\n      var entry = entries.find(ea => ea && (ea.microsoftid == microsoftid))\n      if (entry && entry.value) {\n        papers.push(new Paper(entry.value))\n      } else {\n        rest.push(microsoftid)\n      }\n    } \n    // bulk load the rest\n    if (rest.length > 0) {\n      let list = await this.academicQueryToPapers(this.allReferencesRequery(rest))\n      if (list) papers = papers.concat(list)\n    }\n    return papers\n  }\n  \n  async resolveReferences() {\n    \n    this.references = []\n    if (!this.value.RId) return // nothing to do here    \n    \n    this.references = await this.resolveMicrosoftIdsToPapers(this.value.RId)\n    return this.references\n  }\n  \n  async findReferencedBy() {\n    if (this.referencedBy || !this.microsoftid) return;\n    \n    var entry = await Literature.getPaperEntry(this.microsoftid)\n    if (entry && entry.referencedBy) {\n      this.referencedBy = await this.resolveMicrosoftIdsToPapers(entry.referencedBy)\n    } else {\n      console.log(\"FETCH referencedBy \" + this.microsoftid)\n      \n      this.referencedBy = await this.academicQueryToPapers(\"RId=\" + this.microsoftid)  \n      if (this.referencedBy) {\n        await Literature.patchPaper(this.microsoftid, {\n          referencedBy: this.referencedBy.map(ea => ea.microsoftid)})           \n      }\n    }\n    return this.referencedBy\n  }\n  \n  papersToBibtex(papers) {\n    return `<lively-bibtex>\n      ${\n        papers\n            .map(ea => `<lively-bibtex-entry>${ea.toBibtex()}</lively-bibtex-entry>`)\n            .join(\"\\n\")\n      }\n      </lively-bibtex>` \n  }\n  \n  async toHTML() {\n    await this.resolveReferences() // .then(() => lively.notify(\"resolved references for \" + this.key))\n    await this.findReferencedBy()\n    \n    var bibtexEntries = await this.findBibtexFileEntries()\n    var pdfs = this.value.S && this.value.S.filter(ea => ea.Ty == 3).map(ea => ea.U);\n    \n    return `<div class=\"paper\">\n      <style>\n          .abstract {\n            color: gray;\n            font-style: italic;\n          }\n      </style>\n      <h1 class=\"title\">${\n        this.title\n      } <span class=\"year\">(${\n          this.year\n        })</span>\n      </h1> \n      <h2 class=\"authors\">${\n    this.authors.map(ea => `<a href=\"academic://expr:Composite(AA.AuId=${ea.id})?count=1000\">${ea.name}</a>`).join(\", \")\n      }</h2>\n      <div>\n      <a href=\"bib://${this.key}\">[${this.key}]</a>\n      <span class=\"doi\"><a href=\"https://doi.org/${this.doi}\" target=\"_blank\">${\n        this.doi\n      }</a></span>\n  \n      ${this.value.J ? `<div id=\"journal\">Journal: ` + `<a href=\n        \"academic://expr:And(V='${this.value.V }',I='${this.value.I}',Composite(J.JId=${this.value.J.JId}))?count=100\"\n        }> ` + this.value.J.JN  \n          + \" Volume \" + this.value.V \n          + \" Issue\" + this.value.I + \"</a></div>\": \"\" }\n      <div id=\"conference\">${this.value.C ? this.value.C.CN  : \"\"}</div>\n\n  \n        <div id=\"fields\">${this.value.F ? \"<h3>Fields</h3> \" + \n            this.value.F.map(F => `<a href=\n        \"academic://expr:Composite(F.FId=${F.FId})?count=30\"\n        }> ` + F.DFN + \"</a>\").join(\" \"): \"\" }</div>\n\n  \n      <lively-script><script>\n        import {Paper} from \"src/client/protocols/academic.js\"\n        \n        (<button click={() => lively.openInspector(Paper.byId(${this.microsoftid}))}>inspect</button>)\n      </script></lively-script> \n  \n      </div>\n      ${\n        pdfs.length > 0 ? \n           \"<h3>Online PDFs</h3>\" + pdfs.map(url => `<a href=\"${url}\">${url.replace(/.*\\//,\"\")}</a>`) : \"\"\n      }\n      <h3>Bibliographies</h3>\n      <div>${\n        bibtexEntries.length > 0 ?\n          bibtexEntries.map(ea => `<a href=\"${ea.url}\">${ea.url.replace(/.*\\//,\"\")}</a>`).join(\", \") :\n          \n        `\n<lively-script><script>\n// here comes some inception....\nimport {Paper} from \"src/client/protocols/academic.js\"\nvar container = lively.query(this, \"lively-container\")\nvar result = <button click={async () => {\n  await Paper.importBibtexId(${this.microsoftid})\n  await lively.sleep(1000) // let the indexer do it's work?\n  if (container) container.setPath(container.getPath())\n}}>import bibtex entry</button>\nresult\n</script></livley-script>\n`\n      }</div>\n\n      <h3>Abstract</h3>\n      <div class=\"abstract\">${this.abstract}</div>\n      <h3>References</h3>\n      ${this.papersToBibtex(this.references)}\n      <h3>Referenced By</h3>\n      ${this.papersToBibtex(this.referencedBy)}     \n  </div>`\n  }\n  \n  toBibtex() {\n    var entry = this.toBibtexEntry()\n    return BibtexParser.toBibtex([entry], false);\n  }\n   \n  livelyInspect(contentNode, inspector, normal) {\n    specialInspect(this, contentNode, inspector, normal)\n    contentNode.appendChild(inspector.display(this.toBibtex(), false, \"#bibtex\", this))\n  }\n  \n}\n\nexport default class AcademicScheme extends Scheme {\n\n  get scheme() {\n    return \"academic\";\n  }\n\n  resolve() {\n    return true;\n  }\n\n  static async setSubscriptionKey(key) {\n      return focalStorage.setItem(academicSubscriptionKeyId, key);\n  }\n  \n  \n  static async getSubscriptionKey() {\n    var key = await focalStorage.getItem(academicSubscriptionKeyId);\n    if (!key) {\n      key = await lively.prompt(`Enter your <a href=\"https://msr-apis.portal.azure-api.net/developer\" target=\"_\">Project Academic Knowledge</a> key`, \"\");\n      await this.setSubscriptionKey(key);\n    }\n    return key\n  }\n\n  response(content, contentType = \"text/html\") {\n    return new Response(content, {\n      headers: {\n        \"content-type\": contentType\n      },\n      status: 200\n    });\n  }\n\n  notfound(content, contentType = \"text/html\") {\n    return new Response(content, {\n      headers: {\n        \"content-type\": contentType\n      },\n      status: 303\n    });\n  }\n\n  academicKnowledgeAttributes() {\n    return [\n        [\"Ty\", \"Type\"],\n        [\"AA.AfId\",\"Author affiliation ID\"],\n        [\"AA.AfN\",\"Author affiliation name\"],\n        [\"AA.AuId\",\"Author ID\"],\n        [\"AA.AuN\",\"Normalized author name\"],\n        [\"AA.DAuN\",\"Original author name\"],\n        [\"AA.DAfN\",\"Original affiliation name\"],\n        [\"AA.S\",\"Numeric position in author list\"],\n        [\"AW\",\"Unique, normalized words in abstract, excluding common/stopwords\"],\n        [\"BT\",\"BibTex document type ('a':Journal article, 'b':Book, 'c':Book chapter, 'p':Conference paper)\"],\n        [\"BV\",\"BibTex venue name\"],\n        [\"C.CId\",\"Conference series ID\"],\n        [\"C.CN\",\"Conference series name\"],\n        [\"CC\",\"Citation count\"],\n        [\"CitCon\",\"Citation contexts</br></br>List of referenced paper ID's and the corresponding context in the paper (e.g. [{123:[\\\"brown foxes are known for jumping as referenced in paper 123\\\", \\\"the lazy dogs are a historical misnomer as shown in paper 123\\\"]})\"],\n        [\"D\",\"Date published in YYYY-MM-DD format\"],\n        [\"DN\",\"Original paper title\"],\n        [\"DOI\",\"Digital Object Identifier</br></br>IMPORTANT: The DOI is normalized to uppercase letters, so if querying the field via evaluate/histogram ensure that the DOI value is using all uppercase letters\"],\n        //[\"E\",\"Extended metadata</br></br>IMPORTANT: This attribute has been deprecated and is only supported for legacy applications. Requesting this attribute individually (i.e. attributes=Id,Ti,E) will result in all extended metadata attributes being returned in a serialized JSON string</br></br>All attributes contained in the extended metadata are now available as a top-level attribute and can be requested as such (i.e. attributes=Id,Ti,DOI,IA)\"],\n        [\"ECC\",\"Estimated citation count\"],\n        [\"F.DFN\",\"Original field of study name\"],\n        [\"F.FId\",\"Field of study ID\"],\n        [\"F.FN\",\"Normalized field of study name\"],\n        [\"FamId\",\"If paper is published in multiple venues (e.g. pre-print and conference) with different paper IDs, this ID represents the main/primary paper ID of the family. The field can be used to find all papers in the family group, i.e. FamId=<paper_id>\"],\n        [\"I\",\"Publication issue\"],\n        [\"IA\",\"Inverted abstract\"],\n        [\"Id\",\"Paper ID\"],\n        [\"J.JId\",\"Journal ID\"],\n        [\"J.JN\",\"Journal name\"],\n        [\"FP\",\"First page of paper in publication\"],\n        [\"LP\",\"Last page of paper in publication\"],\n        [\"PB\",\"Publisher\"],\n        [\"Pt\",\"Publication type (0:Unknown, 1:Journal article, 2:Patent, 3:Conference paper, 4:Book chapter, 5:Book, 6:Book reference entry, 7:Dataset, 8:Repository\"],\n        [\"RId\",\"List of referenced paper IDs\"],\n        [\"S\",\"List of source URLs of the paper, sorted by relevance\"],\n        [\"Ti\",\"Normalized title\"],\n        [\"V\",\"Publication volume\"],\n        [\"VFN\",\"Full name of the Journal or Conference venue\"],\n        [\"VSN\",\"Short name of the Journal or Conference venue\"],\n        [\"W\",\"Unique, normalized words in title\"],\n        [\"Y\",\"Year published\"]\n      ].map(ea => ea[0]).join(\",\")\n  }\n  \n  async rawQueryInterpret(textQuery, count) {\n      var interpretation = await fetch(\n        `https://api.labs.cognitive.microsoft.com/academic/v1.0/interpret?query=`\n            + encodeURI(textQuery)\n            + `&complete=1`\n            + `&subscription-key=${await AcademicScheme.getSubscriptionKey()}`).then(r => r.json())\n      if (!interpretation.interpretations[0] || !interpretation.interpretations[0].rules[0]) {\n        return {error: \"no interpretations\", value: interpretation}\n      }\n      \n      var queryExpr = interpretation.interpretations[0].rules[0].output.value\n      return this.rawQueryExpr(queryExpr, count)\n  }\n  \n  async rawQueryExpr(queryExpr, count=10, attributes) {\n    var attributes =  attributes || this.academicKnowledgeAttributes()    \n    var result = await fetch(`cached:https://api.labs.cognitive.microsoft.com/academic/v1.0/evaluate?expr=`\n            + encodeURI(queryExpr)\n            + `&count=${count}`\n            + `&attributes=${attributes}`\n            +`&subscription-key=${await AcademicScheme.getSubscriptionKey()}`).then(r => r.json())\n      return result\n  }\n  \n  async rawQueryHist(queryExpr, attributes=[\"Y\"], count=10) {\n    var result = await fetch(`cached:https://api.labs.cognitive.microsoft.com/academic/v1.0/calchistogram?expr=`\n            + encodeURI(queryExpr)\n            + `&count=${count}`\n            + `&attributes=${attributes}`\n            +`&subscription-key=${await AcademicScheme.getSubscriptionKey()}`).then(r => r.json())\n      return result\n  }\n\n  async entityQuery(queryString, queryType, count, attributes) {\n    let raw;\n    if (queryType==\"expr\") {\n      raw = (await this.rawQueryExpr(queryString, count, attributes))\n    } else {\n      raw = (await this.rawQueryInterpret(queryString, count))\n    }\n    if (raw.entities)  {\n      return  raw.entities\n    } else {\n      return { \n        error: \"could not find entities\", \n        value: raw\n      }\n    }\n  }\n\n  async content(entities) {\n    var content = ``;\n    if (entities.error) return `<span class=\"error\">${entities.error}</span>`\n    \n    var code = `lively.openMarkdown(lively4url + \"/demos/visualizations/academic.md\", \n      \"Academic Visualizaton\", {\n        query: ${JSON.stringify(this.query)},\n        \"count\": ${this.count},\n        \"min_cc_in\": 2,\n        \"min_refs_out\": 10,\n    })`\n    \n    \n\n    content = `<button onclick=\"${code.replace(/\"/g,\"&quot;\")}\">visualize</button>`\n\n    if (this.query.startsWith(\"expr:\")) {\n            var histogramCode = `lively.openMarkdown(lively4url + \"/demos/visualizations/academic-histogram.md\", \n      \"Academic Histogram\", {\n        query: ${JSON.stringify(this.query.replace(/^expr\\:/,\"\"))},\n        \"count\": ${this.count},\n    })`\n    \n    content += `<button onclick=\"${histogramCode.replace(/\"/g,\"&quot;\")}\">histogram</button>`\n    \n    }\n    \n    \n    if (entities.length > 1) {\n      for(var entity of entities) {\n        let paper = await Paper.ensure(entity)\n        content += `<lively-bibtex-entry>${await paper.toBibtex()}</lively-bibtex-entry>`;\n      }      \n    } else if (entities.length == 1) {\n      let paper = await Paper.ensure(entities[0])\n      content += await paper.toHTML() + \"\\n\";\n    } else {\n      content += \"<h1>No entities found</h1>\" + \"\\n\";\n    }\n    return content;\n  }\n\n  async GET(options) {\n    var query = this.url.replace(new RegExp(this.scheme + \"\\:\\/\\/\"), \"\");\n    if (query.length < 2) return this.response(`{\"error\": \"query to short\"}`);\n    \n    \n    var argsString = query.replace(/.*\\?/,\"\")\n    query = query.replace(/\\?.*/,\"\") // strip arguments\n   \n    this.query = query;\n    \n    // adhoc url paremeter decoding...\n    var args = {}\n    argsString.split(/[?&]/).forEach(ea => {\n      var pair = ea.split(\"=\")\n      args[pair[0]] = pair[1]\n    })\n    this.count = args[\"count\"] || 10\n    \n    var attributes = args[\"attr\"]; // optional\n   \n    // example: \n    //  \"expr:Id=3\" -> expr is query type\n    var typeRegex = /^([a-z]*):/\n    var m = query.match(typeRegex)\n    query = decodeURI(query);\n    if (m) {\n      var queryType = m[1]\n      query = query.replace(typeRegex,\"\")\n    }\n    \n    \n    options = options || {}\n    var headers = new Headers(options.headers); // #Refactor we should unify options before\n    \n    if (queryType==\"meta\") {\n      var schemas = await MicrosoftAcademicEntities.schemas()\n      var result = schemas\n      var path = query.split(\"/\")\n      for(let key of path) {\n        try {\n          if (key) {\n            result = result[key]\n          }\n        } catch(e) {\n          this.response(\"could not find \" + query + \" in schemas\");\n        }\n      }\n      \n      \n      return this.response(JSON.stringify(result, undefined, 2), \"application/json\");\n    }\n    \n    if (queryType==\"raw\") {\n      let raw = await this.rawQueryExpr(query, this.count, attributes)\n      return this.response(JSON.stringify(raw, undefined, 2), \"application/json\");      \n    }\n    \n    if (queryType==\"hist\") {\n      if (headers.get(\"content-type\") == \"application/json\") {\n        let raw = (await this.rawQueryHist(query, attributes, this.count))\n        return this.response(JSON.stringify(raw, undefined, 2), \"application/json\");\n      } else {\n        return this.response(`\n<html>\n<lively-script><script>\n  (async () => {\n      var url = lively4url + \"/demos/visualizations/academic-histogram.md\"\n      var comp = await (<lively-markdown style=\"width:100%; height:100%\"></lively-markdown>);\n      var src = await fetch(url).then(r => r.text());\n      comp.parameters = {\n        query: ${JSON.stringify(query)},\n        attr: \"${attributes}\",\n        \"count\": 100,\n      };\n      comp.setContent(src);\n      comp.parentElement.setAttribute(\"title\", \"Academic Histogram\");\n      return comp;\n    })()\n</script><lively-script>        \n        \n\n</html>\n`)        \n  \n      \n      \n      }\n    } \n    \n    let entities = await this.entityQuery(query, queryType, args.count, attributes);\n    if (options && options.headers) {\n      if (headers.get(\"content-type\") == \"application/json\") {\n        return this.response(JSON.stringify(entities), \"application/json\");\n      }\n      \n      if (headers.get(\"content-type\") == \"application/bibtex\") {\n        var papers = []\n        for(let ea of entities) {\n          papers.push(await Paper.ensure(ea))\n        }        \n        return this.response(papers.map(ea => ea.toBibtex()).join(\"\\n\"), \"application/bibtex\");\n      } \n    }\n    // default is HTML\n    var content = await this.content(entities);\n    return this.response(content);\n  }\n\n  async OPTIONS(options) {\n    var content = JSON.stringify({}, undefined, 2);\n    return new Response(content, {\n      headers: {\n        \"content-type\": \"application/json\"\n      },\n      status: 200\n    });\n  }\n\n}\n\nPolymorphicIdentifier.register(AcademicScheme);\n\n// import Tracing from \"src/client/tracing.js\"\n// Tracing.traceClass(Paper)\n"}
{"0":"a","1":"c","2":"a","3":"d","4":"e","5":"m","6":"i","7":"c","8":":","9":"/","10":"/","11":"e","12":"x","13":"p","14":"r","15":":","16":"A","17":"n","18":"d","19":"(","20":"V","21":"=","22":"'","23":"$","24":"{","25":"t","26":"h","27":"i","28":"s","29":".","30":"v","31":"a","32":"l","33":"u","34":"e","35":".","36":"V","37":" ","38":"}","39":"'","40":",","41":"I","42":"=","43":"'","44":"$","45":"{","46":"t","47":"h","48":"i","49":"s","50":".","51":"v","52":"a","53":"l","54":"u","55":"e","56":".","57":"I","58":"}","59":"'","60":",","61":"C","62":"o","63":"m","64":"p","65":"o","66":"s","67":"i","68":"t","69":"e","70":"(","71":"J","72":".","73":"J","74":"I","75":"d","76":"=","77":"$","78":"{","79":"t","80":"h","81":"i","82":"s","83":".","84":"v","85":"a","86":"l","87":"u","88":"e","89":".","90":"J","91":".","92":"J","93":"I","94":"d","95":"}","96":")","97":")","98":"?","99":"c","100":"o","101":"u","102":"n","103":"t","104":"=","105":"1","106":"0","107":"0","from":0,"to":0}
{"0":"a","1":"c","2":"a","3":"d","4":"e","5":"m","6":"i","7":"c","8":":","9":"/","10":"/","11":"e","12":"x","13":"p","14":"r","15":":","16":"C","17":"o","18":"m","19":"p","20":"o","21":"s","22":"i","23":"t","24":"e","25":"(","26":"F","27":".","28":"F","29":"I","30":"d","31":"=","32":"$","33":"{","34":"F","35":".","36":"F","37":"I","38":"d","39":"}","40":")","41":"?","42":"c","43":"o","44":"u","45":"n","46":"t","47":"=","48":"3","49":"0","from":0,"to":0}
{"0":"Ty","1":"Type","from":0,"to":0}
{"0":"Y","1":"Year published","from":0,"to":0}