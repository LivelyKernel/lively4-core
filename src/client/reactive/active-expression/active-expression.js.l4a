{"type":"Reference","version":"49ac68863243f8fc940ec7666da1350273664b80","content":"import Annotations from '../utils/annotations.js';\nimport EventTarget from '../utils/event-target.js';\nimport { shallowEqualsArray, shallowEqualsSet, shallowEqualsMap, shallowEquals, deepEquals } from '../utils/equality.js';\nimport { isString, clone, cloneDeep } from 'utils';\n\n// #TODO: this is use to keep SystemJS from messing up scoping\n// (BaseActiveExpression would not be defined in aexpr)\nconst HACK = {};\n\nwindow.__compareAExprResults__ = false;\n\n/*MD ## Registry of Active Expressions MD*/\nexport const AExprRegistry = {\n\n  _eventTarget: new EventTarget(),\n  _aexprs: new Set(),\n  _idCounters: new Map(),\n\n  /**\n   * Handling membership\n   */\n  addAExpr(aexpr) {\n    this._aexprs.add(aexpr);\n    this.buildIdFor(aexpr);\n    this._eventTarget.dispatchEvent('add', aexpr);\n  },\n  removeAExpr(aexpr) {\n    const deleted = this._aexprs.delete(aexpr);\n    if (deleted) {\n      this._eventTarget.dispatchEvent('remove', aexpr);\n    }\n  },\n  updateAExpr(aexpr) {\n      this._eventTarget.dispatchEvent('update', aexpr);\n  },\n  \n  on(type, callback) {\n    return this._eventTarget.addEventListener(type, callback);\n  },\n  off(type, callback) {\n    return this._eventTarget.removeEventListener(type, callback);\n  },\n  \n  buildIdFor(ae) {\n    let locationId;\n    if(ae.meta().has('location')){\n      let location = ae.meta().get('location');\n      let file = location.file.replace(lively4url+'/', '');\n      locationId = file+'@'+location.start.line+':'+location.start.column;\n    } else {\n      locationId = 'unknown_location';\n    }\n    this._idCounters.set(locationId, this._idCounters.get(locationId) + 1 || 0);\n    ae.meta({id : locationId+'#'+this._idCounters.get(locationId)});       \n  },\n  \n  /**\n   * For Development purpose if the registry gets into inconsistent state\n   */\n  purge() {\n    for(let each of this._aexprs)each._isDisposed = true;\n    this._eventTarget.callbacks.clear();\n    this._aexprs.clear();\n    this._idCounters.clear();\n  },\n\n  /**\n   * Access\n   */\n  allAsArray() {\n    return Array.from(this._aexprs);\n  }\n};\n\n/*MD # Equality Matchers MD*/\nclass DefaultMatcher {\n  static compare(lastResult, newResult) {\n    // array\n    if(Array.isArray(lastResult) && Array.isArray(newResult)) {\n      return shallowEqualsArray(lastResult, newResult);\n    }\n    \n    // set\n    if(lastResult instanceof Set && newResult instanceof Set) {\n      return shallowEqualsSet(lastResult, newResult);\n    }\n\n    // map\n    if(lastResult instanceof Map && newResult instanceof Map) {\n      return shallowEqualsMap(lastResult, newResult);\n    }\n\n    return lastResult === newResult;\n  }\n  \n  static store(result) {\n    // array\n    if(Array.isArray(result)) {\n      return Array.prototype.slice.call(result);\n    }\n    \n    // set\n    if(result instanceof Set) {\n      return new Set(result);\n    }\n    \n    // map\n    if(result instanceof Map) {\n      return new Map(result);\n    }\n    \n    return result;\n  }\n}\n\nclass IdentityMatcher {\n  static compare(lastResult, newResult) {\n    return lastResult === newResult;\n  }\n  \n  static store(result) {\n    return result;\n  }\n}\n\nclass ShallowMatcher {\n  static compare(lastResult, newResult) {\n    // array\n    if(Array.isArray(lastResult) && Array.isArray(newResult)) {\n      return shallowEqualsArray(lastResult, newResult);\n    }\n    \n    // set\n    if(lastResult instanceof Set && newResult instanceof Set) {\n      return shallowEqualsSet(lastResult, newResult);\n    }\n\n    // map\n    if(lastResult instanceof Map && newResult instanceof Map) {\n      return shallowEqualsMap(lastResult, newResult);\n    }\n\n    return shallowEquals(lastResult, newResult) ;\n  }\n  \n  static store(result) {\n    return clone.call(result);\n  }\n}\n\nclass DeepMatcher {\n  static compare(lastResult, newResult) {\n    return deepEquals(lastResult, newResult);\n  }\n  \n  static store(result) {\n    return cloneDeep.call(result);\n  }\n}\n\nconst MATCHER_MAP = new Map([\n  ['default', DefaultMatcher],\n  ['identity', IdentityMatcher],\n  ['shallow', ShallowMatcher],\n  ['deep', DeepMatcher]\n]);\n\nconst NO_VALUE_YET = Symbol('No value yet');\n\n/*MD # ACTIVE EXPRESSIONS MD*/\nexport class BaseActiveExpression {\n\n  /**\n   *\n   * @param func (Function) the expression to be observed\n   * #TODO: incorrect parameter list, how to specify spread arguments in jsdoc?\n   * @param ...params (Objects) the instances bound as parameters to the expression\n   */\n  constructor(func, { params = [], match, errorMode = 'silent', location } = {}) {\n    this._eventTarget = new EventTarget(),\n    this.func = func;\n    this.params = params;\n    this.errorMode = errorMode;\n    this.setupMatcher(match);\n    this._initLastValue();\n    this.callbacks = [];\n    // this.allCallbacks = new Map();\n    this._isDisposed = false;\n    this._shouldDisposeOnLastCallbackDetached = false;\n\n    this._annotations = new Annotations();\n    if(location){this.meta({location})};\n    this.initializeEvents();\n    this.logEvent('created');\n\n    if(new.target === BaseActiveExpression) {\n      this.addToRegistry();\n    }\n  }\n  \n  _initLastValue() {\n    const { value, isError } = this.evaluateToCurrentValue();\n    if (!isError) {\n      this.storeResult(value);\n    } else {\n      this.lastValue = NO_VALUE_YET;\n    }\n  }\n\n  addToRegistry() {\n    AExprRegistry.addAExpr(this);\n  }\n  \n  hasCallbacks() {\n    return this.callbacks.length !== 0;\n  }\n\n  /**\n   * Executes the encapsulated expression with the given parameters.\n   * aliases with 'now' (#TODO: caution, consider ambigous terminology: 'now' as in 'give me the value' or as in 'dataflow'?)\n   * @private\n   * @returns {*} the current value of the expression\n   */\n  getCurrentValue() {\n    return this.func(...this.params);\n  }\n\n  /**\n   * Safely executes the encapsulated expression with the given parameters.\n   * @public\n   * @returns {{ value: *, isError: Boolean}} the current value of the expression, or the thrown error if any\n   */\n  evaluateToCurrentValue() {\n    try {\n      const result = this.getCurrentValue();\n      return { value: result, isError: false };\n    } catch (e) {\n      return { value: e, isError: true };\n    }\n  }\n\n  /*MD ## EventTarget Interface MD*/\n  on(type, callback) {\n    this._eventTarget.addEventListener(type, callback);\n    return this;\n  }\n\n  off(type, callback) {\n    this._eventTarget.removeEventListener(type, callback);\n    return this;\n  }\n\n  emit(type, ...params) {\n    this._eventTarget.dispatchEvent(type, ...params);\n  }\n\n  getEventListeners(type) {\n    return this._eventTarget.getEventListeners(type);\n  }\n\n  /*MD ## --- MD*/\n  /**\n   * @public\n   * @param callback\n   * @returns {BaseActiveExpression} this very active expression (for chaining)\n   */\n  onChange(callback) {\n    this.callbacks.push(callback);\n    this.logEvent('dependencies changed', 'Added: '+callback);\n    AExprRegistry.updateAExpr(this);\n    return this;\n  }\n  /**\n   * @public\n   * @param callback\n   * @returns {BaseActiveExpression} this very active expression (for chaining)\n   */\n  // #TODO: should this remove all occurences of the callback?\n  offChange(callback) {\n    const index = this.callbacks.indexOf(callback);\n    if (index > -1) {\n      this.callbacks.splice(index, 1);\n      this.logEvent('dependencies changed', 'Removed: '+callback);\n      AExprRegistry.updateAExpr(this);\n    }\n    if (this._shouldDisposeOnLastCallbackDetached && this.callbacks.length === 0) {\n      this.dispose();\n    }\n\n    return this;\n  }\n\n  /**\n   * Signals the active expression that a state change might have happened.\n   * Mainly for implementation strategies.\n   * @public\n   */\n  checkAndNotify() {\n    const { value, isError } = this.evaluateToCurrentValue();\n    if(isError || this.compareResults(this.lastValue, value)) { return; }\n    const lastValue = this.lastValue;\n    this.storeResult(value);\n    \n    this.logEvent('changed value', value);\n\n    this.notify(value, {\n      lastValue,\n      expr: this.func ,\n      aexpr: this\n    });\n  }\n  \n  setupMatcher(matchConfig) {\n    // configure using existing matcher\n    if(matchConfig && isString.call(matchConfig)) {\n      if(!MATCHER_MAP.has(matchConfig)) {\n        throw new Error(`No matcher of type '${matchConfig}' registered.`)\n      }\n      this.matcher = MATCHER_MAP.get(matchConfig);\n      return;\n    }\n    \n    // configure using a custom matcher\n    if(typeof matchConfig === 'object') {\n      if(matchConfig.hasOwnProperty('compare') && matchConfig.hasOwnProperty('store')) {\n        this.matcher = matchConfig;\n        return;\n      }\n      throw new Error(`Given matcher object does not provide 'compare' and 'store' methods.`)\n    }\n    \n    // use smart default matcher\n    this.matcher = DefaultMatcher;\n  }\n\n  // #TODO: extract into CompareAndStore classes\n  compareResults(lastResult, newResult) {\n    try {\n      window.__compareAExprResults__ = true;\n      return this.matcher.compare(lastResult, newResult);\n    } finally {\n      window.__compareAExprResults__ = false;\n    }\n  }\n  \n  storeResult(result) {\n    try {\n      window.__compareAExprResults__ = true;\n      this.lastValue = this.matcher.store(result);\n    } finally {\n      window.__compareAExprResults__ = false;\n    }\n  }\n\n  notify(...args) {\n    this.callbacks.forEach(callback => callback(...args));\n    AExprRegistry.updateAExpr(this);\n  }\n\n  onBecomeTrue(callback) {\n    // setup dependency\n    this.onChange(bool => {\n      if(bool) {\n        callback();\n      }\n    });\n\n    // check initial state\n    const { value, isError } = this.evaluateToCurrentValue();\n    if (!isError && value) { callback(); }\n\n    return this;\n  }\n\n  onBecomeFalse(callback) {\n    // setup dependency\n    this.onChange(bool => {\n      if(!bool) {\n        callback();\n      }\n    });\n\n    // check initial state\n    const { value, isError } = this.evaluateToCurrentValue();\n    if(!isError && !value) { callback(); }\n\n    return this;\n  }\n\n  dataflow(callback) {\n    // setup dependency\n    this.onChange(callback);\n\n    // call immediately\n    // #TODO: duplicated code: we should extract this call\n    const { value, isError } = this.evaluateToCurrentValue();\n    if (!isError) {\n      callback(value, {});\n    }\n\n    return this;\n  }\n\n  /*MD ## Disposing MD*/\n  dispose() {\n    if (!this._isDisposed) {\n      this._isDisposed = true;\n      AExprRegistry.removeAExpr(this);\n      this.emit('dispose');\n      this.logEvent('disposed');\n    }\n  }\n\n  isDisposed() {\n    return this._isDisposed;\n  }\n\n  /**\n   * #TODO: implement\n   * disposeOnLastCallbackDetached\n   * chainable\n   * for some auto-cleanup\n   * (only triggers, when a callback is detached; not initially, if there are no callbacks)\n   */\n  disposeOnLastCallbackDetached() {\n    this._shouldDisposeOnLastCallbackDetached = true;\n    return this;\n  }\n\n  gotDisposed() {\n    if (this._disposedPromise) {\n      return this._disposedPromise;\n    }\n\n    return this._disposedPromise = new Promise(resolve => {\n      if (this.isDisposed()) {\n        resolve();\n      } else {\n        this.on('dispose', resolve);\n      }\n    });\n  }\n\n  /*MD ## Reflection Information MD*/\n  meta(annotation) {\n    if(annotation) {\n      this._annotations.add(annotation);\n      return this;\n    } else {\n      return this._annotations;\n    }\n  }\n\n  supportsDependencies() {\n    return false;\n  }\n  \n  initializeEvents() {\n    this.meta({events : new Array()});\n  }\n  \n  logEvent(type, value) {\n    if(this.isMeta())return;\n    //if(!this.meta().has('events'))this.meta({events : new Array()});\n    let events = this.meta().get('events');\n    events.push({timestamp: new Date(), type, value});\n    if(events.length > 5000)events.shift();\n  }\n  \n  isMeta(value) {\n    if(value !== undefined)this.meta({isMeta : value});\n    else return this.meta().has('isMeta') && this.meta().get('isMeta');\n  }\n  \n  /*MD ## Iterators and Utility Methods MD*/\n  nextValue() {\n    return new Promise(resolve => {\n      const callback = value => {\n        this.offChange(callback);\n        resolve(value);\n      };\n      this.onChange(callback);\n    });\n  }\n  \n  then(...args) {\n    return this.nextValue().then(...args);\n  }\n  \n  values() {\n    const gotDisposed = this.gotDisposed();\n    \n    const valueQueue = [];\n    \n    let gotNewValue;\n    let waitForValue;\n    function resetWaitForValue() {\n      waitForValue = new Promise(resolve => {\n        gotNewValue = resolve;\n      });\n    }\n    resetWaitForValue();\n    \n    this.onChange(v => {\n      valueQueue.push(v);\n      const temp = gotNewValue;\n      resetWaitForValue();\n      temp();\n    });\n\n    return {\n      [Symbol.asyncIterator]() {\n        return {\n          next() {\n            if (valueQueue.length > 0) {\n              return {\n                value: valueQueue.shift(),\n                done: false\n              };\n            } else {\n              return Promise.race([\n                waitForValue.then(() => this.next()),\n                gotDisposed.then(() => ({ done: true }))\n              ]);\n            }\n          }\n        };\n      }\n    };\n  }\n}\n\nexport function aexpr(func, ...args) {\n  return new BaseActiveExpression(func, ...args);\n}\n\nexport default BaseActiveExpression;\n"}