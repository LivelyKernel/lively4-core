{"type":"Reference","version":"7d6c3611639a070c0d50972b1fc91f0fae510bf2","content":"\nclass MCTSNode {\n\n  constructor(state, parentNode) {\n    this.visited = false;\n\n    this.state = state;\n    this.parentNode = parentNode;\n\n    // evaluation\n    this.wins = 0;\n    this.playouts = 0;\n  }\n\n  possibleMoves() {\n    const field = this.state.field;\n    const color = this.state.color;\n\n    return field.flatMap((line, i) => line.filterMap((cube, j) => canClick(cube, color) ? { i, j } : undefined));\n  }\n\n  get fullyExpanded() {\n    return this.children.every(([, { visited }]) => visited);\n  }\n\n  get children() {\n    return this._children = this._children || this.possibleMoves().map(move => [move, this.applyMove(move)]);\n  }\n\n  childNodes() {\n    return this._children.map(moveAndChild => moveAndChild[1]);\n  }\n\n  applyMove(move) {\n    return new MCTSNode(doMove(move, cloneState(this.state)), this);\n  }\n\n  // all cubes have same (non-gray) color\n  isTerminal() {\n    const color = this.state.field[0][0].color;\n    if (color === 'gray') {\n      return false;\n    }\n    for (let line of this.state.field) {\n      for (let cube of line) {\n        if (cube.color !== color) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  print() {\n    const field = this.state.field;\n\n    const values = field.map(line => line.map(cube => '%c' + cube.value).join('')).join('\\n');\n    const colors = field.flatMap(line => line.map(cube => 'color:' + cube.color));\n\n    console.log(values, ...colors);\n  }\n\n}\n\nfunction cloneState(state) {\n  const field = state.field.map(line => line.map(cube => ({\n    color: cube.color,\n    value: cube.value,\n    numNeighbours: cube.numNeighbours,\n  })));\n\n  field.forEach((line, i) => line.forEach((cube, j) => {\n    cube.neighbours = [];\n    if (field[i - 1]) {\n      cube.neighbours.push(field[i - 1][j]);\n    }\n    if (field[i][j - 1]) {\n      cube.neighbours.push(field[i][j - 1]);\n    }\n    if (field[i + 1]) {\n      cube.neighbours.push(field[i + 1][j]);\n    }\n    if (field[i][j + 1]) {\n      cube.neighbours.push(field[i][j + 1]);\n    }\n  }));\n\n  return {\n    field,\n    color: state.color,\n  }\n}\n\nfunction canClick(cube, color) {\n  return cube.color === color || cube.color === 'gray';\n}\n\nexport default class MCTS {\n  constructor(rootState) {\n    this.root = new MCTSNode(rootState);\n    this.root.visited = true;\n  }\n\n  async run(resources, { progress = () => {} }) {\n    const allResources = resources;\n\n    const HALF_FRAME = 1000 / 60 / 2;\n    let start = performance.now();\n    const times = [];\n    while (resources-- > 0) {\n      const begin = performance.now();\n      this.step();\n      times.push(performance.now() - begin);\n\n      if (performance.now() - start > HALF_FRAME) {\n        progress(this.root.state.color, 1 - resources / allResources);\n        await new Promise(requestAnimationFrame);\n        start = performance.now();\n      } else {\n        continue;\n      }\n    }\n    lively.warn(times.average())\n\n    // lively.openInspector(this.root)\n    // lively.notify(this.root.children.map(([, c]) => c.wins + '/' + c.playouts).join(' '));\n    return this.root.children.maxBy(([, { playouts }]) => playouts).first;\n  }\n\n  step() {\n    const nodeToExplore = this.selection(this.root);\n    const leaf = this.expansion(nodeToExplore);\n    const result = this.simulation(leaf);\n    this.backpropagation(leaf, result);\n  }\n\n  selection(node) {\n    function bestUCT(node) {\n      return node.children.map(([, childNode]) => childNode).maxBy(childNode => {\n        return childNode.wins / childNode.playouts + Math.SQRT2 * Math.sqrt(Math.log(node.playouts) / childNode.playouts);\n      });\n    }\n    while (node.fullyExpanded && !node.isTerminal()) {\n      node = bestUCT(node);\n    }\n    return node;\n  }\n\n  // pick unvisited child\n  expansion(node) {\n    if (node.isTerminal()) {\n      return node;\n    }\n    return node.children.filter(([, { visited }]) => !visited).map(([, child]) => child).sample() || node;\n  }\n\n  simulation(leafNode) {\n    leafNode.visited = true;\n\n    let node = leafNode;\n    while (!node.isTerminal()) {\n      const moves = node.possibleMoves();\n      const chosenMove = RolloutPolicy.uniformRandom(node, moves);\n      if (node === leafNode) {\n        node = node.applyMove(chosenMove);\n      } else {\n        // quick .applyMove without cloning objects for rest of simulation\n        node = new MCTSNode(doMove(chosenMove, node.state), this);\n      }\n    }\n\n    return this.evaluate(node);\n  }\n\n  evaluate(node) {\n    // lively.notify(node.state.field[0][0].color + ' wins');\n    return node.state.field[0][0].color;\n  }\n\n  backpropagation(node, result) {\n    while (node) {\n      if (node.state.color !== result) {\n        node.wins++;\n      }\n      node.playouts++;\n      node = node.parentNode;\n    }\n  }\n}\n\nclass RolloutPolicy {\n  static uniformRandom(node, moves) {\n    return moves.sample();\n  }\n}\n\n// state: field, color (player on turn)\n// cube: color, value, numNeighbours\n// move: i, j\nfunction doMove({ i, j }, { field, color }) {\n  const moveColor = field[i][j].color;\n  if (moveColor !== color && moveColor !== 'gray') {\n    throw new Error('illegal Move');\n  }\n\n  const numCubes = field.length * field.first.length;\n  let capturedCubes = field.sumBy(line => line.count(cube => cube.color === color));\n\n  let cube;\n  const cubesToIncrement = [field[i][j]];\n  while (cube = cubesToIncrement.shift()) {\n    if (cube.color !== color) {\n      capturedCubes++;\n    }\n    cube.color = color;\n    cube.value++;\n    if (numCubes === capturedCubes) {\n      return { field, color: oppositeColor(color) };\n    }\n\n    if (cube.value > cube.numNeighbours) {\n      cube.value -= cube.numNeighbours;\n      cubesToIncrement.push(...cube.neighbours);\n    }\n  }\n  \n  // layerwiseIncrements(field[i][j], color, numCubes, capturedCubes)\n  // recursiveIncrements(field[i][j], color, numCubes, capturedCubes)\n\n  return { field, color: oppositeColor(color) };\n}\n\nfunction layerwiseIncrements(initialCube, color, numCubes, capturedCubes) {\n  \n  let cubes1 = [initialCube];\n  let cubes2 = [];\n\n  while (cubes1.length > 0) {\n\n    for (let cube1 of cubes1) {\n      if (cube1.color !== color) {\n        capturedCubes++;\n      }\n      cube1.color = color;\n      cube1.value++;\n      if (cube1.value > cube1.numNeighbours) {\n        cube1.value -= cube1.numNeighbours;\n        cubes2.push(...cube1.neighbours);\n      }\n    }\n    cubes1.length = 0;\n\n    for (let cube2 of cubes2) {\n      if (cube2.color !== color) {\n        capturedCubes++;\n      }\n      cube2.color = color;\n      cube2.value++;\n      if (cube2.value > cube2.numNeighbours) {\n        cube2.value -= cube2.numNeighbours;\n        cubes1.push(...cube2.neighbours);\n      }\n    }\n    cubes2.length = 0;\n    \n    if (numCubes === capturedCubes) {\n      return;\n    }\n  }\n}\n\nfunction recursiveIncrements(initialCube, color, numCubes, capturedCubes) {\n  \n  function increment(cube) {\n    if (cube.color !== color) {\n      capturedCubes++;\n    }\n    cube.color = color;\n    cube.value++;\n    if (numCubes === capturedCubes) {\n      return true;\n    }\n\n    if (cube.value > cube.numNeighbours) {\n      cube.value -= cube.numNeighbours;\n      for (let neighbour of cube.neighbours) {\n        increment(neighbour);\n      }\n    }\n  }\n  \n  return increment(initialCube);\n}\n\nfunction oppositeColor(color) {\n  return color === 'red' ? 'green' : 'red';\n}"}