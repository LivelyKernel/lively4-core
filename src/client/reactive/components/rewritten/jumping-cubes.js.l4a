{"type":"Reference","version":"77039b15aef1ac63c34755b94f9de360b610e777","content":"\"enable aexpr\";\n\nimport Morph from 'src/components/widgets/lively-morph.js';\nimport ContextMenu from 'src/client/contextmenu.js';\nimport Strings from 'src/client/strings.js';\nimport MCTS from './jumping-cubes-mcts.js';\n\nimport { shake } from 'utils';\n\nclass Matrix {\n\n  constructor(size) {\n    this.size = size;\n    this.inner = size.times(() => []);\n  }\n\n  get(i, j) {\n    return this.inner[i][j];\n  }\n\n  set(i, j, value) {\n    return this.inner[i][j] = value;\n  }\n\n  static init(size, fn) {\n    const result = new Matrix(size);\n    result.forEach((_, i, j) => {\n      result.set(i, j, fn(i, j));\n    });\n    return result;\n  }\n\n  forEach(fn) {\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size; j++) {\n        fn(this.get(i, j), i, j, this);\n      }\n    }\n  }\n\n  map(fn) {\n    const result = new Matrix(this.size);\n    this.forEach((item, i, j) => {\n      result.set(i, j, fn(item, i, j, this));\n    });\n    return result;\n  }\n\n  indexOf(item) {\n    for (let i = 0; i < this.size; i++) {\n      for (let j = 0; j < this.size; j++) {\n        if (this.get(i, j) === item) {\n          return { i, j };\n        }\n      }\n    }\n  }\n  getNeighboursOf(i, j) {\n    return [{ i: i - 1, j }, { i, j: j - 1 }, { i: i + 1, j }, { i, j: j + 1 }].filter(({ i, j }) => i >= 0 && i < this.size && j >= 0 && j < this.size).map(({ i, j }) => this.get(i, j));\n  }\n\n  sumBy(accessor) {\n    const iter = iteratee(accessor);\n\n    let sum = 0;\n    this.forEach(item => sum += iter(item));\n    return sum;\n  }\n\n  count(predicate) {\n    const iter = iteratee(predicate);\n\n    let counter = 0;\n    this.forEach(item => {\n      if (iter(item)) {\n        counter++;\n      }\n    });\n    return counter;\n  }\n\n  toJSON() {\n    const json = [];\n    this.forEach((item, i, j) => {\n      json[i] = json[i] || [];\n      json[i][j] = item.toJSON();\n    });\n    return json;\n  }\n\n  static fromJSON(json, builder) {\n    if (!Array.isArray(json)) {\n      throw new Error('json for Matrix is no Array');\n    }\n\n    const iter = iteratee(builder);\n    return this.init(json.length, (i, j) => iter(json[i][j]));\n  }\n}\n\nfunction iteratee(value) {\n  if (typeof value == 'function') {\n    return value;\n  }\n\n  if (value == null) {\n    return Function.identity;\n  }\n\n  if (typeof value == 'string') {\n    return function (object) {\n      return object == null ? undefined : object[value];\n    };\n  }\n\n  return () => {};\n}\n\nclass Cube {\n\n  constructor(jc, { value, color }) {\n    this.jc = jc;\n\n    this.value = value;\n    this.color = color;\n\n    this.initElement();\n  }\n\n  initElement() {\n    this.button = <button class=\"cube\" click={evt => this.onClick(evt)}>~</button>;\n    this.shaker = <div class=\"shaker\">{this.button}</div>;\n    this.bouncer = <div class=\"bouncer\">{this.shaker}</div>;\n    this.exploder = <div class=\"exploder\">{this.bouncer}</div>;\n    this.container = <div class=\"cube-container\" mouseleave={evt => {\n      this.button.style.transform = 'rotateX(0deg) rotateY(0deg)';\n      this.button.style.filter = 'brightness(1)';\n    }} mousemove={evt => {\n      const width = this.button.clientWidth;\n      const height = this.button.clientHeight;\n      const mouseX = evt.offsetX;\n      const mouseY = evt.offsetY;\n      const rotateY = mouseX.remap([0, width], [-35, 35], true);\n      const rotateX = mouseY.remap([0, height], [35, -35], true);\n      const brightness = mouseY.remap([0, height], [1.5, 0.5], true) * mouseX.remap([0, width], [1.25, 0.75], true);\n\n      this.button.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;\n      this.button.style.filter = `brightness(${brightness})`;\n    }}>{this.exploder}</div>;\n  }\n\n  async onClick(evt) {\n    if (!this.jc.handleClickOn(this)) {\n      shake(this.shaker);\n    }\n  }\n\n  get neighbours() {\n    if (this._neighbours) {\n      return this._neighbours;\n    }\n\n    const cubes = this.jc.cubes;\n\n    const index = cubes.indexOf(this);\n    if (!index) {\n      return [];\n    }\n\n    return this._neighbours = cubes.getNeighboursOf(index.i, index.j);\n  }\n\n  toJSON() {\n    return {\n      color: this.color,\n      value: this.value\n    };\n  }\n}\n\nconst EFFECT_DURATION = 400;\n\nclass Animation {\n  constructor(jc) {\n    this.jc = jc;\n    this.gameNumber = jc.gameNumber;\n  }\n}\n\nclass Increment extends Animation {\n  constructor(cube, color, jc) {\n    super(jc);\n    this.cube = cube;\n    this.color = color;\n  }\n\n  async run() {\n    const duration = this.jc.duration(EFFECT_DURATION);\n\n    this.cube.bouncer.animate([{ transform: 'translateY(0px)' }, { transform: 'translateY(-30px)' }, { transform: 'translateY(0px)' }], {\n      duration,\n      easing: 'ease-in-out',\n      composite: 'accumulate'\n    });\n\n    this.cube.bouncer.animate([{ transform: 'scale(1, 1.3)', offset: 0.35 }, { transform: 'scale(1.1, 0.9)', offset: 0.5 }, { transform: 'scale(1, 1.3)', offset: 0.65 }], {\n      duration,\n      easing: 'ease-in-out',\n      composite: 'accumulate'\n    });\n\n    this.cube.button.animate([{ backgroundColor: 'white' }, { backgroundColor: COLOR_MAP.get(this.color) }], {\n      duration,\n      easing: 'ease-in-out',\n      fill: 'both'\n    }, 'accumulate');\n\n    await lively.sleep(duration / 2);\n    if (this.gameNumber < this.jc.gameNumber) {\n      return;\n    }\n    this.cube.color = this.color;\n    this.cube.value++;\n    return lively.sleep(duration / 2);\n  }\n}\n\nclass Explode extends Animation {\n  constructor(cube, jc) {\n    super(jc);\n    this.cube = cube;\n  }\n\n  async run() {\n    const duration = this.jc.duration(EFFECT_DURATION);\n    const jc = this.jc;\n\n    const neighbours = this.cube.neighbours;\n    if (this.cube.value <= neighbours.length) {\n      return;\n    }\n\n    this.cube.exploder.animate([{ transform: 'translateY(0px)' }, { transform: 'translateY(-20px)' }, { transform: 'translateY(0px)' }], {\n      duration,\n      easing: 'ease-in-out',\n      composite: 'accumulate'\n    });\n\n    this.cube.exploder.animate([{ transform: 'scale(1, 1.3)', offset: 0.35 }, { transform: 'scale(1.1, 0.9)', offset: 0.5 }, { transform: 'scale(1, 1.3)', offset: 0.65 }], {\n      duration,\n      easing: 'ease-in-out',\n      composite: 'accumulate'\n    });\n\n    this.cube.button.animate([{ backgroundColor: 'black' }, { backgroundColor: COLOR_MAP.get(jc.player.color) }], {\n      duration,\n      easing: 'ease-in-out',\n      fill: 'both'\n    }, 'accumulate');\n\n    await lively.sleep(duration / 2);\n    if (this.cube.value <= neighbours.length) {\n      return;\n    }\n    if (this.gameNumber < this.jc.gameNumber) {\n      return;\n    }\n    this.cube.color = jc.player.color;\n    this.cube.value -= neighbours.length;\n    neighbours.forEach(neighbour => {\n      jc.addAnimation(new Increment(neighbour, this.cube.color, jc));\n    });\n\n    return lively.sleep(duration / 2);\n  }\n}\n\nconst COLOR_MAP = new Map([['red', 'rgba(255, 126, 126, 1.0)'], ['green', 'rgba(126, 255, 126, 1.0)'], ['gray', 'rgba(176, 176, 176, 1.0)']]);\n\nclass AnimationQueue {\n  constructor(jc) {\n    this.jc = jc;\n    this.gameNumber = jc.gameNumber;\n    this.inner = [];\n  }\n\n  add(animation) {\n    this.inner.push(animation);\n    this.resolveAnim && this.resolveAnim();\n  }\n\n  async process() {\n    const TASK_DURATION = this.jc.duration(100);\n\n    let lastAnim;\n    while (true) {\n      while (this.inner.length > 0) {\n        // that.innerHTML = this.inner.length;\n        const next = this.inner.shift();\n        lastAnim = next.run();\n        await lively.sleep(TASK_DURATION);\n      }\n\n      await Promise.race([lastAnim, new Promise(resolve => this.resolveAnim = resolve)]);\n\n      if (this.inner.length === 0) {\n        return;\n      }\n    }\n  }\n\n  clear() {\n    this.inner.length = 0;\n  }\n}\n\nclass Player {\n  constructor(color, ai) {\n    this.color = color;\n    this.ai = ai;\n  }\n\n  startTurn(jc) {\n    if (this.ai) {\n      jc.classList.add('noClickAllowed');\n      this.gameNumber = jc.gameNumber;\n      this.aiTurn(jc);\n    } else {\n      jc.classList.remove('noClickAllowed');\n    }\n  }\n\n  async aiTurn(jc) {\n    function getInitialState(jc) {\n      const cubes = jc.cubes;\n      const color = jc.player.color;\n\n      const field = cubes.toJSON();\n\n      field.forEach((line, i) => line.forEach((cube, j) => {\n        cube.neighbours = [];\n        if (field[i - 1]) {\n          cube.neighbours.push(field[i - 1][j]);\n        }\n        if (field[i][j - 1]) {\n          cube.neighbours.push(field[i][j - 1]);\n        }\n        if (field[i + 1]) {\n          cube.neighbours.push(field[i + 1][j]);\n        }\n        if (field[i][j + 1]) {\n          cube.neighbours.push(field[i][j + 1]);\n        }\n      }));\n\n      field.forEach(line => line.forEach(cube => cube.numNeighbours = cube.neighbours.length));\n\n      return { field, color };\n    }\n\n    jc.aiProgressStart(jc.player.color)\n\n    const mcts = new MCTS(getInitialState(jc));\n    const move = await mcts.run(1000, {\n      progress: ::jc.aiProgressStep\n    });\n\n    if (this.gameNumber < jc.gameNumber) {\n      return;\n    }\n\n    jc.aiProgressEnd()\n    jc.processQueue(jc.cubes.get(move.i, move.j));\n  }\n\n  static fromJSON(json) {\n    return new Player(json.color, json.ai);\n  }\n  toJSON() {\n    return {\n      color: this.color,\n      ai: this.ai\n    };\n  }\n}\n\nexport default class JumpingCubes extends Morph {\n\n  get field() {\n    return this.get('#field');\n  }\n\n  set energy(value) {\n    return this.get('#energy').innerHTML = value;\n  }\n\n  defaultStart() {\n    const { startingValue, fieldSize } = this.getConfig();\n    return Matrix.init(fieldSize, () => ({\n      value: startingValue,\n      color: 'gray'\n    }));\n  }\n\n  async initialize() {\n    this.windowTitle = \"Jumping Cubes\";\n\n    this.init();\n\n    const state = this.getJSONAttribute('state');\n    this.reset(state);\n\n    this.get('#gameEnd-container').addEventListener('click', ::this.restart);\n  }\n\n  get fieldSize() {\n    return this.cubes.size;\n  }\n  init() {\n    this.addEventListener('contextmenu', evt => this.onContextMenu(evt), false);\n    this.gameNumber = 0;\n    this.aexprs = new Set();\n  }\n\n  reset(state) {\n    this.blinkOut();\n    const aiProgress = this.aiProgress;\n    aiProgress.animate([{ 'opacity': 0 }], {\n      duration: 0,\n      fill: 'forwards'\n    });\n\n    this.gameNumber++;\n    this.animationSpeed = this.getConfig().animationSpeed;\n    this.animations = new AnimationQueue(this);\n\n    let startingInfo;\n    if (state) {\n      this.players = state.players.map(Player.fromJSON);\n      this.setPlayerForIndex(state.currentPlayerIndex);\n      startingInfo = Matrix.fromJSON(state.cubes, cubeDesc => _.pick(cubeDesc, ['value', 'color']));\n    } else {\n      this.createPlayers();\n      this.initStartingPlayer();\n      startingInfo = this.defaultStart();\n    }\n\n    this.buildFieldOfCubes(startingInfo);\n\n    // #TODO connect: this.energy <= this.cubes.sumBy('value')\n    this.ae(() => this.cubes.sumBy('value')).dataflow(v => this.energy = v);\n\n    const checkEnd = (color, v) => {\n      const numCubes = this.fieldSize * this.fieldSize;\n      if (v >= numCubes) {\n        this.win(color);\n      }\n    };\n    this.ae(() => this.cubes.count(cube => cube.color === 'green')).dataflow(v => this.get('#greenPlayer').innerHTML = v).onChange(v => checkEnd('green', v));\n    this.ae(() => this.cubes.count(cube => cube.color === 'red')).dataflow(v => this.get('#redPlayer').innerHTML = v).onChange(v => checkEnd('red', v));\n\n    this.saveToAttribute();\n    this.startTurnForCurrentPlayer();\n  }\n\n  createPlayers() {\n    this.currentPlayerIndex = 0;\n    this.players = this.getConfig().players.map(Player.fromJSON);\n  }\n\n  buildFieldOfCubes(startingInfo) {\n    this.field.innerHTML = '';\n    this.cubes = startingInfo.map(info => {\n      const cube = new Cube(this, info);\n\n      this.field.appendChild(cube.container);\n\n      return cube;\n    });\n\n    this.cubes.forEach(cube => {\n      this.ae(() => cube.value).dataflow(value => cube.button.innerHTML = value).dataflow(value => {\n        if (value > cube.neighbours.length) {\n          this.addAnimation(new Explode(cube, this));\n        }\n      });\n      this.ae(() => cube.color).dataflow(value => cube.button.style.background = COLOR_MAP.get(value));\n    });\n\n    const fieldSize = this.cubes.size;\n    this.field.style.setProperty('grid-template-columns', `repeat(${fieldSize}, 40px)`);\n    this.field.style.setProperty('grid-template-rows', `repeat(${fieldSize}, 40px)`);\n  }\n\n  initStartingPlayer() {\n    this.setPlayerForIndex(0);\n  }\n  nextPlayer() {\n    this.setPlayerForIndex(this.currentPlayerIndex + 1);\n  }\n  setPlayerForIndex(index) {\n    this.currentPlayerIndex = index % this.players.length;\n    this.player = this.players[this.currentPlayerIndex];\n    this.style.setProperty('--playerOnTurn', this.player.color);\n  }\n\n  startTurnForCurrentPlayer() {\n    this.player.startTurn(this);\n  }\n  clickRandomCube() {\n    const color = this.player.color;\n    function canClick(cube) {\n      return cube.color === color || cube.color === 'gray';\n    }\n\n    const clickables = [];\n    this.cubes.forEach(cube => {\n      if (canClick(cube)) {\n        clickables.push(cube);\n      }\n    });\n\n    this.processQueue(clickables.sample());\n  }\n\n  ae(fn, ...opts) {\n    const ae = aexpr(fn, ...opts);\n    this.aexprs.add(ae);\n    return ae;\n  }\n\n  handleClickOn(cube) {\n    if (cube.color === this.player.color || cube.color === 'gray') {\n      if (!this.classList.contains('noClickAllowed')) {\n        this.processQueue(cube);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // #important\n  async processQueue(cube) {\n    this.animationSpeed = this.getConfig().animationSpeed;\n    this.classList.add('noClickAllowed');\n    this.addAnimation(new Increment(cube, this.player.color, this));\n\n    const animationQueue = this.animations;\n    await animationQueue.process();\n    if (animationQueue.gameNumber < this.gameNumber) {\n      return;\n    }\n    this.nextPlayer();\n    this.saveToAttribute();\n    this.startTurnForCurrentPlayer();\n  }\n  addAnimation(animation) {\n    this.animations.add(animation);\n  }\n  duration(duration) {\n    const speed = this.animationSpeed;\n    if (speed === 'Instantaneous') {\n      return 0;\n    }\n    if (_.isNumber(speed)) {\n      return duration / speed;\n    }\n    return 1;\n  }\n\n  detachedCallback() {\n    this.disposeBindings();\n  }\n\n  disposeBindings() {\n    this.aexprs.forEach(ae => ae.dispose());\n    this.aexprs.clear();\n  }\n\n  defaultConfig() {\n    return {\n      fieldSize: 5,\n      startingValue: 2,\n      animationSpeed: 1,\n      players: [{\n        color: 'green',\n        ai: false\n      }, {\n        color: 'red',\n        ai: true\n      }]\n    };\n  }\n  getConfig() {\n    function loadJSON(key) {\n      const stringValue = this.getItem(key);\n      if (!stringValue) {\n        return undefined;\n      }\n      return JSON.parse(stringValue);\n    }\n\n    const config = localStorage::loadJSON('JumpingCubes');\n    if (config) {\n      return config;\n    }\n    return this.defaultConfig();\n  }\n  setConfig(config) {\n    function saveJSON(key, json) {\n      const stringValue = JSON.stringify(json, undefined, 2);\n      return this.setItem(key, stringValue);\n    }\n\n    return localStorage::saveJSON('JumpingCubes', config);\n  }\n  resetConfig() {\n    return localStorage.removeItem('JumpingCubes');\n  }\n  configure(callback) {\n    const config = this.getConfig();\n    callback(config);\n    this.setConfig(config);\n  }\n\n  onContextMenu(evt) {\n    evt.stopPropagation();\n    evt.preventDefault();\n\n    function fa4(classes) {\n      return '<i class=\"fa fa-' + classes + '\" aria-hidden=\"true\"></i>';\n    }\n\n    const players = this.getConfig().players.map((player, index) => {\n      function checkIcon(enabled) {\n        return enabled ? fa4('check-square-o') : fa4('square-o');\n      }\n\n      return [`player ${player.color}`, (evt, item) => {\n        evt.stopPropagation();\n        evt.preventDefault();\n\n        let isAI;\n        this.configure(conf => isAI = conf.players[index].ai = !conf.players[index].ai);\n        item.querySelector(\".icon\").innerHTML = checkIcon(isAI);\n      }, '', { toString: () => checkIcon(this.getConfig().players[index].ai) }];\n    });\n\n    const radioButtonList = (values, configProperty) => {\n      function radioIcon(enabled) {\n        return enabled ? fa4('dot-circle-o') : fa4('circle-o');\n      }\n\n      return values.map((value, index) => [value + '', (evt, item) => {\n        evt.stopPropagation();\n        evt.preventDefault();\n\n        this.configure(conf => conf[configProperty] = value);\n        item.parentElement.querySelectorAll(\".icon\").forEach((icon, iconIndex) => {\n          icon.innerHTML = radioIcon(index === iconIndex);\n        });\n      }, '', { toString: () => radioIcon(value === this.getConfig()[configProperty]) }]);\n    };\n    const fieldSizes = radioButtonList(2 .to(13), 'fieldSize');\n    const startingValues = radioButtonList([1, 2], 'startingValue');\n    const animationSpeed = radioButtonList([0.5, 0.75, 1, 1.25, 1.5, 2, 4, 'Instantaneous'], 'animationSpeed');\n\n    const items = [];\n    items.push([\"restart game\", ::this.restart, '', fa4('fast-backward')]);\n    items.push([\"new game\", () => lively.openComponentInWindow('jumping-cubes')]);\n    items.push([\"players\", players, '', fa4('users')]);\n    items.push([\"field size\", fieldSizes, '', fa4('cubes')]);\n    items.push([\"starting value\", startingValues, '', fa4('cube')]);\n    items.push([\"animation speed\", animationSpeed, '', fa4('cube')]);\n    items.push([\"reset to default\", ::this.resetConfig, '', fa4('trash-o')]);\n\n    const menu = new ContextMenu(this, items);\n    menu.openIn(document.body, evt, this);\n  }\n\n  restart() {\n    this.cleanup();\n    this.reset();\n  }\n\n  async blinkOut() {\n    if (!this.blinked) {\n      return;\n    }\n    this.blinked = false;\n\n    const container = this.get('#gameEnd-container');\n    const winText = this.get('#gameEnd-message');\n    const clickText = this.get('#gameEnd-newGame');\n\n    const mainDuration = 300;\n    container.animate([{ 'backgroundColor': 'rgba(255, 255, 255, 0.1)' }, { 'backgroundColor': 'rgba(255, 255, 255, 0)' }], {\n      duration: mainDuration,\n      easing: 'ease-out',\n      fill: 'forwards'\n    });\n    winText.animate([{ 'opacity': 1, 'transform': 'scaleY(1)' }, { 'opacity': 0, 'transform': 'scaleY(0.5)' }], {\n      duration: mainDuration,\n      easing: 'ease-out',\n      fill: 'forwards'\n    });\n    clickText.style.setProperty('opacity', 0);\n    clickText.animate([{ 'opacity': 1 }, { 'opacity': 0 }], {\n      duration: mainDuration,\n      easing: 'ease-out',\n      fill: 'forwards'\n    });\n\n    await lively.sleep(mainDuration);\n    container.style.setProperty('display', 'none');\n  }\n\n  blinkIn(color) {\n    if (this.blinked) {\n      return;\n    }\n    this.blinked = true;\n\n    const container = this.get('#gameEnd-container');\n    const winText = this.get('#gameEnd-message');\n    const clickText = this.get('#gameEnd-newGame');\n\n    winText.innerHTML = `Player ${Strings.toUpperCaseFirst(color)} Wins!`;\n    winText.style.setProperty('background-color', COLOR_MAP.get(color));\n\n    const mainDuration = 300;\n    container.style.setProperty('display', 'grid');\n    container.animate([{ 'backgroundColor': 'rgba(255, 255, 255, 0)' }, { 'backgroundColor': 'rgba(255, 255, 255, 0.7)' }, { 'backgroundColor': 'rgba(255, 255, 255, 0.1)' }], {\n      duration: mainDuration * 1.5,\n      easing: 'ease-out',\n      fill: 'forwards'\n    });\n    winText.animate([{ 'opacity': 0, 'transform': 'scaleY(0.5)' }, { 'opacity': 1, 'transform': 'scaleY(1)' }], {\n      duration: mainDuration,\n      easing: 'cubic-bezier(0.34, 2.56, 0.64, 1)',\n      fill: 'forwards'\n    });\n    clickText.style.setProperty('opacity', 0);\n    clickText.animate([{ 'opacity': 0 }, { 'opacity': 1 }], {\n      duration: 1000,\n      easing: 'ease-out',\n      delay: mainDuration,\n      fill: 'forwards'\n    });\n  }\n\n  cleanup() {\n    this.disposeBindings();\n    this.classList.remove('noClickAllowed');\n    this.gameNumber++;\n  }\n\n  win(color) {\n    this.cleanup();\n    this.blinkIn(color);\n  }\n\n  get aiProgress() {\n    return this.get('#ai-progress');\n  };\n  \n  get aiProgressLabel() {\n    return this.get('#ai-progress-label');\n  };\n  \n  aiProgressStart(color) {\n    const aiProgress = this.aiProgress;\n    aiProgress.style.display = 'block';\n    aiProgress.style.backgroundImage =``;\n    aiProgress.style.setProperty('opacity', 0);\n    aiProgress.animate([{ 'opacity': 0 }, { 'opacity': 1 }], {\n      duration: 1000,\n      easing: 'ease-out',\n      fill: 'forwards'\n    });\n\n    const aiProgressLabel = this.aiProgressLabel;\n    aiProgressLabel.style.color = color;\n  }\n\n  aiProgressStep(color, progress) {\n    const aiProgress = this.aiProgress;\n    let cssColor;\n    if (color === 'red') {\n      cssColor = '255, 0, 0'\n    } else if (color === 'green') {\n      cssColor = '0, 255, 0'\n    } else {\n      cssColor = '0, 0, 255'\n    }\n    const progressPercentage = progress * 100;\n    aiProgress.style.backgroundImage =`linear-gradient( \n      to right,\n      rgba(${cssColor}, 0.45), \n      rgba(${cssColor}, 0.45) ${progressPercentage}%,\n      rgba(0,0,0,0) ${progressPercentage}%,\n      rgba(0,0,0,0)\n    )`;\n\n    const aiProgressLabel = this.aiProgressLabel;\n    aiProgressLabel.style.color = color;\n  }\n\n  aiProgressEnd() {\n    const aiProgress = this.aiProgress;\n    aiProgress.animate([{ 'opacity': 1 }, { 'opacity': 0 }], {\n      duration: 500,\n      easing: 'ease-out',\n      fill: 'forwards'\n    });\n  }\n\n  /* Lively-specific API */\n\n  toJSON() {\n    return {\n      currentPlayerIndex: this.currentPlayerIndex,\n      players: this.players.map(p => p.toJSON()),\n\n      fieldSize: this.cubes.size,\n      cubes: this.cubes.toJSON()\n    };\n  }\n\n  saveToAttribute() {\n    this.setJSONAttribute('state', this.toJSON());\n  }\n\n  // store something that would be lost\n  livelyPrepareSave() {\n    // this.setAttribute(\"data-mydata\", this.get(\"#textField\").value);\n  }\n\n  livelyPreMigrate() {\n    this.disposeBindings();\n  }\n\n  livelyMigrate(other) {\n    const state = other.getJSONAttribute('state');\n    this.setJSONAttribute('state', state);\n    this.classList.remove('noClickAllowed');\n  }\n\n  async livelyExample() {\n    this.style.backgroundColor = \"lightgray\";\n  }\n\n}"}